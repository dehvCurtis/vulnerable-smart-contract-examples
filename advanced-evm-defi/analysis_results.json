{
  "version": "1.3.0",
  "timestamp": "2025-11-07T00:39:48.293784Z",
  "findings": [
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 22,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Struct contains mixed uint256 and smaller types. Pack smaller types together for gas savings Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 303,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'destroy' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 61,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
        "replacements": []
      }
    },
    {
      "detector_id": "deprecated-functions",
      "message": "Deprecated function or pattern detected: 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns",
      "severity": "low",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-477",
      "fix_suggestion": {
        "description": "Replace deprecated 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns",
        "replacements": []
      }
    },
    {
      "detector_id": "hardware-wallet-delegation",
      "message": "Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.",
        "replacements": []
      }
    },
    {
      "detector_id": "time-locked-admin-bypass",
      "message": "Timelock implementation incomplete - missing queue/schedule or execute functions",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Implement complete timelock flow: propose‚Üíqueue‚Üíwait(delay)‚Üíexecute",
        "replacements": []
      }
    },
    {
      "detector_id": "time-locked-admin-bypass",
      "message": "Emergency functions bypass timelock without multisig protection",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Require multisig approval for emergency functions that bypass timelock",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Hardcoded decimal assumption (18) - incompatible with USDC (6), WBTC (8), etc.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Call token.decimals() and normalize: uint256 decimals = token.decimals(); amount * 10**decimals",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Token price/exchange calculation without decimal normalization - incorrect conversions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Decimal-sensitive math operations without validation - verify decimal assumptions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "Static fees on AMM - no protection against toxic flow from informed traders",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Implement dynamic fees that increase with volatility or trade size to discourage toxic flow",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "No trade size limits - large informed trades can extract maximum value from LPs",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Add maximum trade size as percentage of reserves: require(amountIn < reserves * maxBps / 10000)",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "Instant arbitrage possible - informed traders can extract value with zero risk",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Add block delay or use time-weighted pricing to reduce instant arbitrage opportunities",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "No JIT liquidity protection - attackers can add liquidity, extract fees, and withdraw immediately",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Add minimum holding period for LP tokens: mapping(address => uint256) public depositTime",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.20;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.20;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "unused-state-variables",
      "message": "State variable 'token0' is declared but never used. Unused state variables waste storage slots and increase deployment gas costs. Each unused storage slot costs gas during deployment.",
      "severity": "low",
      "location": {
        "line": 144,
        "column": 0,
        "length": 6
      },
      "cwe": "CWE-563",
      "fix_suggestion": {
        "description": "Remove unused state variable 'token0'. If this variable is intended for future use, consider adding a TODO comment. If it needs to maintain storage layout for upgradeable contracts, add a comment explaining this.",
        "replacements": []
      }
    },
    {
      "detector_id": "unused-state-variables",
      "message": "State variable 'token1' is declared but never used. Unused state variables waste storage slots and increase deployment gas costs. Each unused storage slot costs gas during deployment.",
      "severity": "low",
      "location": {
        "line": 145,
        "column": 0,
        "length": 6
      },
      "cwe": "CWE-563",
      "fix_suggestion": {
        "description": "Remove unused state variable 'token1'. If this variable is intended for future use, consider adding a TODO comment. If it needs to maintain storage layout for upgradeable contracts, add a comment explaining this.",
        "replacements": []
      }
    },
    {
      "detector_id": "selfdestruct-recipient-manipulation",
      "message": "SELFDESTRUCT recipient is not validated (can force ether to contracts)",
      "severity": "high",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-477",
      "fix_suggestion": {
        "description": "Validate recipient address: require(recipient != address(0) && isApproved(recipient)). Be aware that selfdestruct can force ether to contracts that don't accept it.",
        "replacements": []
      }
    },
    {
      "detector_id": "extcodesize-bypass",
      "message": "EOA-only modifier uses EXTCODESIZE (bypassable during constructor)",
      "severity": "medium",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-754",
      "fix_suggestion": {
        "description": "Modifier restricts to EOAs using EXTCODESIZE. This can be bypassed by calling from a contract constructor. Use tx.origin == msg.sender if strict EOA requirement is needed.",
        "replacements": []
      }
    },
    {
      "detector_id": "extcodesize-bypass",
      "message": "Requires msg.sender.code.length == 0 (bypassable during constructor)",
      "severity": "medium",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-754",
      "fix_suggestion": {
        "description": "Checking msg.sender.code.length == 0 can be bypassed during construction. If you need to restrict to EOAs, use tx.origin == msg.sender, but be aware of phishing risks.",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-storage-collision",
      "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n‚úÖ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n‚úÖ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Percentage calculation - verify order of operations for precision",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Percentage calculations require careful ordering:\n\n‚ùå WRONG (precision loss):\nuint256 fee = (amount / 10000) * feePercent;\n\n‚úÖ CORRECT:\nuint256 fee = (amount * feePercent) / 10000;\n\n‚úÖ BEST (with basis points):\nuint256 constant BASIS_POINTS = 10000;\nuint256 fee = (amount * feeBasisPoints) / BASIS_POINTS;\n\nExample: 250 basis points = 2.5%\namount = 1000, feeBasisPoints = 250\nfee = (1000 * 250) / 10000 = 25 ‚úÖ\n\nWRONG order:\nfee = (1000 / 10000) * 250 = 0 * 250 = 0 ‚ùå",
        "replacements": []
      }
    },
    {
      "detector_id": "oracle-time-window-attack",
      "message": "Using getReserves() for pricing - this is a spot price, not time-weighted",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "getReserves() returns SPOT price - manipulable in single block!\n\nAttack: Flash loan ‚Üí Swap large amount ‚Üí getReserves() ‚Üí Exploit ‚Üí Unwind\n\n‚ùå INSECURE:\n(uint112 reserve0, uint112 reserve1,) = pair.getReserves();\nprice = reserve1 * 1e18 / reserve0;  // Spot price!\n\n‚úÖ SECURE - Use TWAP instead:\n// For Uniswap V2:\nuint256 price0CumulativeLast = pair.price0CumulativeLast();\nuint32 blockTimestamp = uint32(block.timestamp % 2**32);\nuint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n// Calculate TWAP\nFixedPoint.uq112x112 memory price0Avg = FixedPoint.uq112x112(\nuint224((price0Cumulative - price0CumulativeLast) / timeElapsed)\n);\n\n// For Uniswap V3: Use observe() as shown above",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Transfer function without zero-value check - validate non-zero amounts",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n‚úÖ VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n‚úÖ COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Address parameter without zero-address validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n‚úÖ VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n‚úÖ VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Unchecked block found - overflows/underflows won't revert (OWASP 2025)",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ö†Ô∏è UNCHECKED BLOCKS BYPASS SOLIDITY 0.8.0+ PROTECTION!\n\nSolidity 0.8.0+ has automatic overflow/underflow checks,\nbut 'unchecked' blocks disable this protection.\n\n‚ùå DANGEROUS if user input involved:\nunchecked {\nbalance += amount;  // Can overflow!\ntotal = a * b;      // Can overflow!\n}\n\n‚úÖ SAFE usage (loop counters only):\nfor (uint256 i = 0; i < items.length;) {\n// Process items[i]\n\nunchecked {\n++i;  // Safe: loop counter can't realistically overflow\n}\n}\n\n‚úÖ SAFE usage (guaranteed no overflow):\nunchecked {\n// Safe: subtraction after comparison\nif (a >= b) {\nresult = a - b;  // No underflow possible\n}\n}\n\n‚ùå NEVER use unchecked for:\n- User-supplied values\n- Token amounts\n- Financial calculations\n- Multiplication of arbitrary values\n\nOnly use unchecked when:\n1. Loop counters (i++, ++i)\n2. Mathematically proven safe\n3. Gas optimization with careful review",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "üö® CRITICAL: Assembly has NO overflow protection!\n\nReal incident: Cetus DEX - $223M loss (May 2025)\nCause: Assembly arithmetic overflow\n\n‚ùå VULNERABLE (Cetus-style vulnerability):\nassembly {\nlet result := add(a, b)  // NO OVERFLOW CHECK!\nlet product := mul(x, y) // NO OVERFLOW CHECK!\nmstore(0x00, result)\n}\n\n‚úÖ SOLUTION 1 - Add manual checks:\nassembly {\nlet result := add(a, b)\n// Manual overflow check\nif lt(result, a) {\nrevert(0, 0)  // Overflow detected\n}\n}\n\n‚úÖ SOLUTION 2 - Use Solidity instead:\n// Let Solidity handle overflow checks\nuint256 result = a + b;  // Automatic overflow check\n\n‚úÖ SOLUTION 3 - SafeMath for assembly:\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c;\nassembly {\nc := add(a, b)\n}\nrequire(c >= a, \"Overflow\");  // Check outside assembly\nreturn c;\n}\n\nAssembly arithmetic operations with NO checks:\n- add(a, b)     ‚Üí wraps on overflow\n- sub(a, b)     ‚Üí wraps on underflow\n- mul(a, b)     ‚Üí wraps on overflow\n- div(a, b)     ‚Üí returns 0 if b is 0 (no revert!)\n\n‚ö†Ô∏è Only use assembly arithmetic when absolutely necessary\nand with manual overflow checks!",
        "replacements": []
      }
    },
    {
      "detector_id": "jit-liquidity-sandwich",
      "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "hook-reentrancy-enhanced",
      "message": "External call in before-hook without reentrancy protection - attacker can re-enter during swap",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Add reentrancy guard (nonReentrant modifier) or follow checks-effects-interactions pattern in hook functions",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "No minimum deposit requirement - small deposits may round down to zero shares",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-invariant-manipulation",
      "message": "AMM swap lacks K invariant validation - reserves can be manipulated without proper checks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Enforce K invariant (reserve0 * reserve1 >= k) after every swap to prevent reserve manipulation",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-invariant-manipulation",
      "message": "Swap function supports callbacks without reentrancy guard - vulnerable to reentrancy via flash swaps",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 15376
      },
      "fix_suggestion": {
        "description": "Add reentrancy guard to swap function or validate invariants before and after callback execution",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 54,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "selfdestruct-abuse",
      "message": "Function 'destroy' contains selfdestruct abuse vulnerability. Selfdestruct vulnerability marker detected Selfdestruct permanently destroys the contract and can force-send ether to any address, bypassing fallback functions and breaking assumptions.",
      "severity": "high",
      "location": {
        "line": 61,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-670",
      "fix_suggestion": {
        "description": "Restrict or remove selfdestruct in 'destroy'. Add access control (onlyOwner), implement time-lock, or use withdraw pattern instead of selfdestruct. Consider that contracts expecting ether may not have payable fallback.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'destroy' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 61,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'destroy'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'destroy' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 61,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'destroy'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "diamond-storage-collision",
      "message": "Contract 'TerminableContract' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
      "severity": "critical",
      "location": {
        "line": 51,
        "column": 10,
        "length": 18
      },
      "cwe": "CWE-1321",
      "fix_suggestion": {
        "description": "Implement Diamond Storage pattern for 'TerminableContract': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.terminablecontract\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'to' in function 'transferEOAsOnly' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 88,
        "column": 39,
        "length": 2
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(to != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'to' of type 'address' may need validation",
      "severity": "high",
      "location": {
        "line": 88,
        "column": 39,
        "length": 2
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(to != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 88,
        "column": 51,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 79,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'transferEOAsOnly' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 88,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'transferEOAsOnly'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'restrictedOperation' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 109,
        "column": 14,
        "length": 19
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'restrictedOperation'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'transferEOAsOnly' contains excessive gas usage pattern. Multiple storage reads detected (4). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 88,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'transferEOAsOnly'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'transferEOAsOnly' contains variable shadowing. Local variable 'codeSize' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 88,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'transferEOAsOnly'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "diamond-storage-collision",
      "message": "Contract 'VulnerableEOACheck' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
      "severity": "critical",
      "location": {
        "line": 75,
        "column": 10,
        "length": 18
      },
      "cwe": "CWE-1321",
      "fix_suggestion": {
        "description": "Implement Diamond Storage pattern for 'VulnerableEOACheck': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.vulnerableeoacheck\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
        "replacements": []
      }
    },
    {
      "detector_id": "single-oracle-source",
      "message": "Function '' relies on a single oracle source, creating centralization risk",
      "severity": "high",
      "location": {
        "line": 124,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-693",
      "fix_suggestion": {
        "description": "Use multiple oracle sources and implement price aggregation in function ''",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function '' does not check return value",
      "severity": "medium",
      "location": {
        "line": 124,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function ''",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 124,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 140,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-liquidity-pool-manipulation",
      "message": "No reentrancy protection (flash loan attack risk) in 'swap'",
      "severity": "critical",
      "location": {
        "line": 140,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'swap' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV",
      "severity": "critical",
      "location": {
        "line": 140,
        "column": 14,
        "length": 4
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'swap': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'beforeAddLiquidity' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'beforeAddLiquidity'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'afterRemoveLiquidity' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 208,
        "column": 14,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'afterRemoveLiquidity'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'sender' in function 'beforeSwap' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 158,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(sender != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'sender' in function 'afterSwap' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 176,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(sender != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'sender' in function 'beforeAddLiquidity' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 192,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(sender != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'sender' in function 'afterRemoveLiquidity' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 209,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(sender != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'sender' of type 'address' may need validation",
      "severity": "low",
      "location": {
        "line": 158,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(sender != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amountSpecified' of type 'int' may need validation",
      "severity": "low",
      "location": {
        "line": 161,
        "column": 16,
        "length": 15
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amountSpecified > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'sender' of type 'address' may need validation",
      "severity": "low",
      "location": {
        "line": 176,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(sender != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amountSpecified' of type 'int' may need validation",
      "severity": "low",
      "location": {
        "line": 179,
        "column": 16,
        "length": 15
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amountSpecified > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'sender' of type 'address' may need validation",
      "severity": "low",
      "location": {
        "line": 192,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(sender != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount0' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 194,
        "column": 17,
        "length": 7
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount0 > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount1' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 195,
        "column": 17,
        "length": 7
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount1 > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'sender' of type 'address' may need validation",
      "severity": "low",
      "location": {
        "line": 209,
        "column": 17,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(sender != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount0' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 211,
        "column": 17,
        "length": 7
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount0 > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount1' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 212,
        "column": 17,
        "length": 7
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount1 > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 157,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-liquidity-manipulation",
      "message": "Function 'beforeSwap' is vulnerable to AMM liquidity manipulation. AMM function performs external calls without reentrancy protection, enabling manipulation of reserves during callback Liquidity manipulation can drain pools, enable sandwich attacks, or allow attackers to profit from price manipulation.",
      "severity": "critical",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'beforeSwap' from liquidity manipulation. Implement minimum liquidity locks, use TWAP oracles instead of spot prices, add reentrancy guards, validate reserves before and after trades, and implement trade size limits.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-fee-manipulation",
      "message": "Function 'beforeAddLiquidity' may be vulnerable to fee manipulation attack. Unprotected fee update without timelock. Fee changes take effect immediately, enabling front-running attacks Attacker can front-run fee changes to extract value from depositors.",
      "severity": "medium",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect 'beforeAddLiquidity' from fee manipulation. Solutions: (1) Implement timelock delay on fee updates (24-48 hours minimum), (2) Emit events before fee changes take effect with advance notice, (3) Add maximum fee change limits per update (e.g., max 2% fee), (4) Require multi-sig approval for fee changes (Gnosis Safe pattern), (5) Use gradual fee ramping instead of instant updates (Curve style), (6) Implement MEV protection patterns for fee-dependent operations, (7) Consider OpenZeppelin TimelockController for governance.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-impact-manipulation",
      "message": "Function 'beforeSwap' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
      "severity": "high",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add price impact protection to 'beforeSwap'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-impact-manipulation",
      "message": "Function 'afterSwap' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
      "severity": "high",
      "location": {
        "line": 175,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add price impact protection to 'afterSwap'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'beforeSwap' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'beforeSwap'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'afterSwap' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 175,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'afterSwap'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'beforeSwap' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'beforeSwap'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'afterSwap' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 175,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'afterSwap'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'beforeAddLiquidity' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'beforeAddLiquidity'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'afterRemoveLiquidity' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 208,
        "column": 14,
        "length": 20
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'afterRemoveLiquidity'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "circular-dependency",
      "message": "Function 'beforeSwap' has circular dependency vulnerability. Callback pattern without reentrancy guard, enables circular call chains and reentrancy attacks Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
      "severity": "high",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-674",
      "fix_suggestion": {
        "description": "Break circular dependency in 'beforeSwap'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'beforeSwap' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'beforeSwap'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'afterSwap' contains unsafe type casting. int to uint conversion without sign check. Negative values will wrap to large positive Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 184,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'afterSwap'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'afterSwap' contains unsafe type casting. uint to int conversion without overflow check. Large values may become negative Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 184,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'afterSwap'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-liquidity-pool-manipulation",
      "message": "No reentrancy protection (flash loan attack risk) in 'beforeSwap'",
      "severity": "critical",
      "location": {
        "line": 157,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-liquidity-pool-manipulation",
      "message": "No reentrancy protection (flash loan attack risk) in 'afterSwap'",
      "severity": "critical",
      "location": {
        "line": 175,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-liquidity-pool-manipulation",
      "message": "No minimum liquidity lock (pool initialization attack) in 'beforeAddLiquidity'",
      "severity": "high",
      "location": {
        "line": 191,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Lock minimum: if (totalSupply == 0) { liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY; _mint(address(0), MINIMUM_LIQUIDITY); }",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No minimum lock period enforced (instant liquidity removal) in 'beforeAddLiquidity'",
      "severity": "high",
      "location": {
        "line": 191,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Enforce minimum: uint256 constant MIN_LOCK_PERIOD = 1 hours; // or appropriate duration",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No cooldown period between add and remove liquidity in 'beforeAddLiquidity'",
      "severity": "medium",
      "location": {
        "line": 191,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add cooldown: require(block.timestamp >= lastDeposit[msg.sender] + COOLDOWN_PERIOD, \"Cooldown active\");",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No entry fee to discourage JIT liquidity provision in 'beforeAddLiquidity'",
      "severity": "low",
      "location": {
        "line": 191,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Consider entry fee: Apply small fee on liquidity provision to make JIT attacks unprofitable",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No lock time validation on liquidity removal in 'afterRemoveLiquidity'",
      "severity": "critical",
      "location": {
        "line": 208,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Enforce lock: require(block.timestamp >= liquidityLockTime[msg.sender] + MIN_LOCK_PERIOD, \"Locked\");",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No early exit fee (JIT attacks profitable) in 'afterRemoveLiquidity'",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add exit fee: if (block.timestamp < lockTime + EXTENDED_PERIOD) { applyEarlyExitFee(); }",
        "replacements": []
      }
    },
    {
      "detector_id": "uniswapv4-hook-issues",
      "message": "Uniswap V4 hook function 'beforeSwap' has security issues: Hook contains external calls without reentrancy protection, enabling potential callback manipulation attacks; Hook function lacks validation checks (require/revert), which may allow invalid operations to proceed; Hook callback lacks access control checks, allowing unauthorized addresses to trigger hook logic; Hook fee extraction lacks maximum fee cap, allowing unlimited fee extraction from users",
      "severity": "high",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-691",
      "fix_suggestion": {
        "description": "Secure hook 'beforeSwap': Add reentrancy guards, validate return selectors, implement proper access control (onlyPool modifier), cap fee extraction, and follow checks-effects-interactions pattern",
        "replacements": []
      }
    },
    {
      "detector_id": "uniswapv4-hook-issues",
      "message": "Uniswap V4 hook function 'afterSwap' has security issues: Hook contains external calls without reentrancy protection, enabling potential callback manipulation attacks; Hook function lacks validation checks (require/revert), which may allow invalid operations to proceed; Hook callback lacks access control checks, allowing unauthorized addresses to trigger hook logic; Hook fee extraction lacks maximum fee cap, allowing unlimited fee extraction from users",
      "severity": "high",
      "location": {
        "line": 175,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-691",
      "fix_suggestion": {
        "description": "Secure hook 'afterSwap': Add reentrancy guards, validate return selectors, implement proper access control (onlyPool modifier), cap fee extraction, and follow checks-effects-interactions pattern",
        "replacements": []
      }
    },
    {
      "detector_id": "uniswapv4-hook-issues",
      "message": "Uniswap V4 hook function 'beforeAddLiquidity' has security issues: Hook contains external calls without reentrancy protection, enabling potential callback manipulation attacks; Hook function lacks validation checks (require/revert), which may allow invalid operations to proceed; Hook callback lacks access control checks, allowing unauthorized addresses to trigger hook logic; Hook fee extraction lacks maximum fee cap, allowing unlimited fee extraction from users",
      "severity": "high",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-691",
      "fix_suggestion": {
        "description": "Secure hook 'beforeAddLiquidity': Add reentrancy guards, validate return selectors, implement proper access control (onlyPool modifier), cap fee extraction, and follow checks-effects-interactions pattern",
        "replacements": []
      }
    },
    {
      "detector_id": "uniswapv4-hook-issues",
      "message": "Uniswap V4 hook function 'afterRemoveLiquidity' has security issues: Hook contains external calls without reentrancy protection, enabling potential callback manipulation attacks; Hook function lacks validation checks (require/revert), which may allow invalid operations to proceed; Hook callback lacks access control checks, allowing unauthorized addresses to trigger hook logic; Hook fee extraction lacks maximum fee cap, allowing unlimited fee extraction from users",
      "severity": "high",
      "location": {
        "line": 208,
        "column": 14,
        "length": 20
      },
      "cwe": "CWE-691",
      "fix_suggestion": {
        "description": "Secure hook 'afterRemoveLiquidity': Add reentrancy guards, validate return selectors, implement proper access control (onlyPool modifier), cap fee extraction, and follow checks-effects-interactions pattern",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'beforeSwap' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV; K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 157,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'beforeSwap': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'afterSwap' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV; K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 175,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'afterSwap': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'beforeAddLiquidity' violates constant product invariant: K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'beforeAddLiquidity': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'afterRemoveLiquidity' violates constant product invariant: K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 208,
        "column": 14,
        "length": 20
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'afterRemoveLiquidity': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'beforeAddLiquidity' updates fees without proper protections. No access control on fee updates. Anyone can modify fees leading to manipulation Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'beforeAddLiquidity': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'beforeAddLiquidity' updates fees without proper protections. Fee updates take immediate effect. Should implement time delay to prevent front-running Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'beforeAddLiquidity': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'beforeAddLiquidity' updates fees without proper protections. No event emission for fee updates. Users cannot track fee changes or prepare for them Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'beforeAddLiquidity': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'beforeAddLiquidity' updates fees without proper protections. No rate limiting on fee updates. Fees could be changed too frequently causing instability Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'beforeAddLiquidity': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'beforeAddLiquidity' updates fees without proper protections. No validation of new fee value. Should enforce reasonable bounds on fee changes Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 191,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'beforeAddLiquidity': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 225,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 233,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-liquidity-pool-manipulation",
      "message": "No reentrancy protection (flash loan attack risk) in 'swap'",
      "severity": "critical",
      "location": {
        "line": 233,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'swap' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV",
      "severity": "critical",
      "location": {
        "line": 233,
        "column": 14,
        "length": 4
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'swap': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'addLiquidity' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 264,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'addLiquidity'",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount0' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 264,
        "column": 35,
        "length": 7
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount0 > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount1' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 264,
        "column": 52,
        "length": 7
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount1 > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 273,
        "column": 32,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "single-oracle-source",
      "message": "Function 'flashSwap' relies on a single oracle source, creating centralization risk",
      "severity": "high",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-693",
      "fix_suggestion": {
        "description": "Use multiple oracle sources and implement price aggregation in function 'flashSwap'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'flashSwap' does not check return value",
      "severity": "medium",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'flashSwap'",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-attack",
      "message": "Function 'flashSwap' may be vulnerable to sandwich attacks due to predictable execution order",
      "severity": "medium",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Consider implementing commit-reveal schemes or using a decentralized oracle in function 'flashSwap'",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 244,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "oracle-manipulation",
      "message": "Function 'calculatePrice' uses spot price from oracle without flash loan protection. Attackers can manipulate pool reserves via flash loans to skew oracle prices, enabling profitable liquidations or unfair trades.",
      "severity": "critical",
      "location": {
        "line": 255,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Use Time-Weighted Average Price (TWAP) instead of spot prices, or implement multi-oracle validation with deviation checks in function 'calculatePrice'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-slippage-protection",
      "message": "Function 'buyTokens' executes DEX swap without slippage protection (amountOutMin = 0). This allows MEV bots to sandwich the transaction, extracting value through front-running and back-running attacks.",
      "severity": "high",
      "location": {
        "line": 248,
        "column": 0,
        "length": 9
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Calculate minimum acceptable output amount based on current price and acceptable slippage (e.g., 0.5-1%). Example: uint256 minOut = expectedAmount * 99 / 100; Then use minOut instead of 0 in swap call in function 'buyTokens'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-slippage-protection",
      "message": "Function 'flashSwap' executes DEX swap without slippage protection (amountOutMin = 0). This allows MEV bots to sandwich the transaction, extracting value through front-running and back-running attacks.",
      "severity": "high",
      "location": {
        "line": 277,
        "column": 0,
        "length": 9
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Calculate minimum acceptable output amount based on current price and acceptable slippage (e.g., 0.5-1%). Example: uint256 minOut = expectedAmount * 99 / 100; Then use minOut instead of 0 in swap call in function 'flashSwap'",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-liquidity-manipulation",
      "message": "Function 'calculatePrice' is vulnerable to AMM liquidity manipulation. Price calculation uses current reserves without slippage protection, deadline checks, or minimum output validation Liquidity manipulation can drain pools, enable sandwich attacks, or allow attackers to profit from price manipulation.",
      "severity": "critical",
      "location": {
        "line": 255,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'calculatePrice' from liquidity manipulation. Implement minimum liquidity locks, use TWAP oracles instead of spot prices, add reentrancy guards, validate reserves before and after trades, and implement trade size limits.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-impact-manipulation",
      "message": "Function 'buyTokens' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
      "severity": "high",
      "location": {
        "line": 244,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add price impact protection to 'buyTokens'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-impact-manipulation",
      "message": "Function 'flashSwap' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
      "severity": "high",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add price impact protection to 'flashSwap'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-impact-manipulation",
      "message": "Function 'executeTrade' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
      "severity": "high",
      "location": {
        "line": 284,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add price impact protection to 'executeTrade'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'buyTokens' lacks sandwich attack protection. No deadline parameter to prevent delayed execution, allowing validators to hold and execute swap at unfavorable prices MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 244,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'buyTokens'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'flashSwap' lacks sandwich attack protection. No deadline parameter to prevent delayed execution, allowing validators to hold and execute swap at unfavorable prices MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'flashSwap'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'executeTrade' lacks sandwich attack protection. No deadline parameter to prevent delayed execution, allowing validators to hold and execute swap at unfavorable prices MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 284,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'executeTrade'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'buyTokens' has extractable MEV. Swap function with spot pricing creates arbitrage opportunities, MEV bots can profit from price differences Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 244,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'buyTokens'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'buyTokens' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 244,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'buyTokens'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'flashSwap' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'flashSwap'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "front-running-mitigation",
      "message": "Function 'buyTokens' lacks front-running protection. Trading function 'buyTokens' missing deadline parameter. Transaction can be held and executed at unfavorable time Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
      "severity": "high",
      "location": {
        "line": 244,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add front-running protection to 'buyTokens'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-liquidity-pool-manipulation",
      "message": "No minimum liquidity lock (pool initialization attack) in 'addLiquidity'",
      "severity": "high",
      "location": {
        "line": 264,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Lock minimum: if (totalSupply == 0) { liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY; _mint(address(0), MINIMUM_LIQUIDITY); }",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-liquidity-pool-manipulation",
      "message": "No reentrancy protection (flash loan attack risk) in 'flashSwap'",
      "severity": "critical",
      "location": {
        "line": 273,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No minimum lock period enforced (instant liquidity removal) in 'addLiquidity'",
      "severity": "high",
      "location": {
        "line": 264,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Enforce minimum: uint256 constant MIN_LOCK_PERIOD = 1 hours; // or appropriate duration",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No cooldown period between add and remove liquidity in 'addLiquidity'",
      "severity": "medium",
      "location": {
        "line": 264,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add cooldown: require(block.timestamp >= lastDeposit[msg.sender] + COOLDOWN_PERIOD, \"Cooldown active\");",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-jit-liquidity-attacks",
      "message": "No entry fee to discourage JIT liquidity provision in 'addLiquidity'",
      "severity": "low",
      "location": {
        "line": 264,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Consider entry fee: Apply small fee on liquidity provision to make JIT attacks unprofitable",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'buyTokens' violates constant product invariant: Swap lacks deadline parameter, transactions may execute at unfavorable prices if delayed",
      "severity": "critical",
      "location": {
        "line": 244,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'buyTokens': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'calculatePrice' violates constant product invariant: Reserve updates don't verify constant product (K) invariant (x*y >= k), allowing pool imbalance and potential value extraction",
      "severity": "critical",
      "location": {
        "line": 255,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'calculatePrice': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'flashSwap' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV",
      "severity": "critical",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'flashSwap': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'executeTrade' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV",
      "severity": "critical",
      "location": {
        "line": 284,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'executeTrade': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "lending-borrow-bypass",
      "message": "Lending protocol function 'flashSwap' has borrow bypass vulnerabilities: Flash loan lacks same-block borrow restriction, may be exploited to bypass health factor checks",
      "severity": "critical",
      "location": {
        "line": 273,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure lending function 'flashSwap': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 313,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'commit' has dangerous timestamp dependency. Performs arithmetic on block.timestamp without overflow protection, potentially manipulable by miners within bounds Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 313,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'commit'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'reveal' has dangerous timestamp dependency. Uses keccak256 with block variables (timestamp/difficulty/number/prevrandao) for randomness. These values are predictable/manipulable by miners and validators, enabling attacks on randomness-dependent logic. Use Chainlink VRF or commit-reveal schemes instead Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 326,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'reveal'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'commitWithDelay' has dangerous timestamp dependency. Performs arithmetic on block.timestamp without overflow protection, potentially manipulable by miners within bounds Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 343,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'commitWithDelay'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'weakCommit' has dangerous timestamp dependency. Uses keccak256 with block variables (timestamp/difficulty/number/prevrandao) for randomness. These values are predictable/manipulable by miners and validators, enabling attacks on randomness-dependent logic. Use Chainlink VRF or commit-reveal schemes instead Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 356,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'weakCommit'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "block-stuffing-vulnerable",
      "message": "Function 'reveal' is vulnerable to block stuffing attacks. First-come-first-served mechanism with strict ordering, attackers can stuff blocks to prevent others from participating Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.",
      "severity": "high",
      "location": {
        "line": 326,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate block stuffing in 'reveal'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "block-stuffing-vulnerable",
      "message": "Function 'weakCommit' is vulnerable to block stuffing attacks. Auction closes in single block without multi-block finalization period, vulnerable to block stuffing to prevent last-minute bids Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.",
      "severity": "high",
      "location": {
        "line": 356,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate block stuffing in 'weakCommit'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'weakCommit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 356,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'weakCommit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "insufficient-randomness",
      "message": "Function 'reveal' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
      "severity": "high",
      "location": {
        "line": 326,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-338",
      "fix_suggestion": {
        "description": "Use secure randomness in 'reveal'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
        "replacements": []
      }
    },
    {
      "detector_id": "insufficient-randomness",
      "message": "Function 'weakCommit' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
      "severity": "high",
      "location": {
        "line": 356,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-338",
      "fix_suggestion": {
        "description": "Use secure randomness in 'weakCommit'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'commit' contains variable shadowing. Parameter 'commitment' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 313,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'commit'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 377,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'reveal' has dangerous timestamp dependency. Uses keccak256 with block variables (timestamp/difficulty/number/prevrandao) for randomness. These values are predictable/manipulable by miners and validators, enabling attacks on randomness-dependent logic. Use Chainlink VRF or commit-reveal schemes instead Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 386,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'reveal'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "insufficient-randomness",
      "message": "Function 'reveal' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
      "severity": "high",
      "location": {
        "line": 386,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-338",
      "fix_suggestion": {
        "description": "Use secure randomness in 'reveal'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
        "replacements": []
      }
    },
    {
      "detector_id": "insufficient-randomness",
      "message": "Function 'determineWinner' uses weak randomness source. Uses blockhash for randomness. Only last 256 blocks accessible, miners can influence, not available for future blocks Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
      "severity": "high",
      "location": {
        "line": 400,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-338",
      "fix_suggestion": {
        "description": "Use secure randomness in 'determineWinner'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'determineWinner' contains unsafe type casting. int to uint conversion without sign check. Negative values will wrap to large positive Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 402,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'determineWinner'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'determineWinner' contains unsafe type casting. uint to int conversion without overflow check. Large values may become negative Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 402,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'determineWinner'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.0",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.0"
  },
  "statistics": {
    "total_findings": 160,
    "severity_counts": {
      "critical": 27,
      "medium": 36,
      "low": 23,
      "info": 0,
      "high": 74
    },
    "unique_detectors": 52
  }
}