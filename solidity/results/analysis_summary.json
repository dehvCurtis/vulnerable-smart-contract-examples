[
  {
    "contract": "AccessControl",
    "total_findings": 79,
    "critical": 15,
    "high": 36,
    "medium": 21,
    "low": 7,
    "detectors": {
      "missing-access-modifiers": 4,
      "unprotected-initializer": 1,
      "invalid-state-transition": 3,
      "missing-zero-address-check": 5,
      "parameter-consistency": 5,
      "unchecked-external-call": 3,
      "test-governance": 4,
      "storage-collision": 1,
      "dangerous-delegatecall": 1,
      "vault-withdrawal-dos": 2,
      "vault-hook-reentrancy": 1,
      "mev-extractable-value": 4,
      "circular-dependency": 1,
      "gas-griefing": 2,
      "excessive-gas-usage": 1,
      "inefficient-storage": 2,
      "centralization-risk": 1,
      "shadowing-variables": 4,
      "aa-initialization-vulnerability": 3,
      "hardware-wallet-delegation": 2,
      "erc20-transfer-return-bomb": 1,
      "defi-yield-farming-exploits": 7,
      "floating-pragma": 1,
      "diamond-storage-collision": 2,
      "transient-storage-reentrancy": 2,
      "eip7702-init-frontrun": 1,
      "eip7702-delegate-access-control": 1,
      "eip7702-storage-collision": 1,
      "eip7702-txorigin-bypass": 1,
      "missing-commit-reveal": 1,
      "logic-error-patterns": 2,
      "enhanced-input-validation": 3,
      "enhanced-access-control": 1,
      "jit-liquidity-sandwich": 1,
      "single-oracle-source": 1,
      "validator-front-running": 1,
      "block-stuffing-vulnerable": 1,
      "front-running-mitigation": 1
    },
    "findings": [
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'changeOwner' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 19,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'changeOwner'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'initialize' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 34,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'initialize'",
          "replacements": []
        }
      },
      {
        "detector_id": "unprotected-initializer",
        "message": "Initializer function 'initialize' lacks access control and can be called by anyone",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier to 'initialize' or ensure it can only be called once during deployment",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 28,
          "column": 9,
          "length": 51
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variable 'initialized' is modified without proper validation or state checks",
        "severity": "high",
        "location": {
          "line": 38,
          "column": 9,
          "length": 18
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add proper validation before modifying state variables",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_newOwner' in function 'changeOwner' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 19,
          "column": 34,
          "length": 9
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_newOwner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_recipient' in function 'withdrawAll' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 34,
          "length": 10
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_recipient != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_owner' in function 'initialize' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 33,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_owner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_target' in function 'execute' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 42,
          "column": 30,
          "length": 7
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_target != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_newOwner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 19,
          "column": 34,
          "length": 9
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_newOwner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_recipient' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 25,
          "column": 34,
          "length": 10
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_recipient != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_owner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 33,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_owner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_target' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 42,
          "column": 30,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_target != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'withdrawAll' does not check return value",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'withdrawAll'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 14,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Function 'execute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
        "severity": "medium",
        "location": {
          "line": 42,
          "column": 0,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Implement time-delayed voting rights requiring minimum holding periods.",
          "replacements": []
        }
      },
      {
        "detector_id": "storage-collision",
        "message": "Function 'execute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Ensure storage layout compatibility in 'execute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function 'execute' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in 'execute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdrawAll' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdrawAll' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-hook-reentrancy",
        "message": "Function 'withdrawAll' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'withdrawAll' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'withdrawAll' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'withdrawAll'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function '' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 49,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in ''. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'execute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 42,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'execute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'withdrawAll' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'withdrawAll'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 34,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 32,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 34,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'withdrawAll' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'withdrawAll'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-306",
        "fix_suggestion": {
          "description": "Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
        "severity": "high",
        "location": {
          "line": 15,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
        "severity": "high",
        "location": {
          "line": 21,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
          "replacements": []
        }
      },
      {
        "detector_id": "hardware-wallet-delegation",
        "message": "Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-672",
        "fix_suggestion": {
          "description": "Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "hardware-wallet-delegation",
        "message": "Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3146
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No withdrawal fee accounting (fee bypass risk) in 'withdrawAll'",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Asset calculation missing totalSupply/totalAssets in 'withdrawAll'",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No slippage protection on withdrawal in 'withdrawAll'",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add slippage: require(assets >= minAssets, \"Slippage too high\");",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "diamond-storage-collision",
        "message": "Contract 'VulnerableWallet' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
        "severity": "critical",
        "location": {
          "line": 10,
          "column": 10,
          "length": 16
        },
        "cwe": "CWE-1321",
        "fix_suggestion": {
          "description": "Implement Diamond Storage pattern for 'VulnerableWallet': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.vulnerablewallet\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Classic reentrancy pattern with transient storage risk in 'withdrawAll'",
        "severity": "critical",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() \u2190 attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 \u2190 do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-init-frontrun",
        "message": "Unprotected initialization in 'initialize' - vulnerable to front-running takeover ($1.54M August 2025 attack)",
        "severity": "critical",
        "location": {
          "line": 34,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-7702 Front-Running Attack:\n\nCurrent code (VULNERABLE):\nfunction initialize(...) public {\nrequire(owner == address(0));\nowner = newOwner;  // \u274c Attacker can front-run!\n}\n\nAttack sequence:\n1. User signs EIP-7702 authorization\n2. Attacker sees authorization in mempool\n3. Attacker front-runs with initialize(attackerAddress)\n4. User's delegation is now controlled by attacker\n5. Attacker drains all assets\n\nFix 1: Authorization-based initialization\nfunction initialize(address _owner, bytes memory signature) public {\nrequire(owner == address(0));\n\n// \u2705 Verify user signed this specific initialization\nbytes32 hash = keccak256(abi.encodePacked(_owner, address(this)));\naddress signer = ECDSA.recover(hash, signature);\nrequire(signer == _owner, \"Invalid signature\");\n\nowner = _owner;\n}\n\nFix 2: Constructor initialization (if possible)\nconstructor(address _owner) {\nowner = _owner;  // \u2705 Set during deployment\n}\n\nFix 3: Factory pattern with immediate initialization\ncontract DelegateFactory {\nfunction createDelegate() public returns (address) {\nDelegate delegate = new Delegate(msg.sender);\nreturn address(delegate);\n}\n}\n\nFix 4: Commit-reveal with time-lock\nmapping(bytes32 => uint256) public commitments;\n\nfunction commitInit(bytes32 commitment) public {\ncommitments[commitment] = block.timestamp;\n}\n\nfunction initialize(address _owner, bytes32 salt) public {\nbytes32 commitment = keccak256(abi.encodePacked(_owner, salt));\nrequire(commitments[commitment] > 0, \"No commitment\");\nrequire(block.timestamp >= commitments[commitment] + 10 minutes);\n\nowner = _owner;\n}\n\nReal-World Loss: $1.54M (August 2025)",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'execute' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-storage-collision",
        "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-txorigin-bypass",
        "message": "tx.origin usage breaks with EIP-7702 delegation",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-7702 breaks tx.origin assumptions:\n\nBefore: tx.origin == msg.sender for EOAs\nAfter EIP-7702: tx.origin != msg.sender (msg.sender is delegate)\n\nFix: Use msg.sender instead:\nrequire(msg.sender == owner, \"Not owner\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-commit-reveal",
        "message": "Auction/bidding without commit-reveal - bids can be front-run",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Implement commit-reveal pattern:\n\nmapping(address => bytes32) public commitments;\nmapping(address => uint256) public bids;\nuint256 public commitDeadline;\nuint256 public revealDeadline;\n\n// Phase 1: Commit (hide bid amount)\nfunction commitBid(bytes32 commitment) external {\nrequire(block.timestamp < commitDeadline);\ncommitments[msg.sender] = commitment;\n}\n\n// Phase 2: Reveal (after commit deadline)\nfunction revealBid(uint256 amount, bytes32 salt) external payable {\nrequire(block.timestamp >= commitDeadline);\nrequire(block.timestamp < revealDeadline);\n\nbytes32 commitment = keccak256(abi.encode(amount, salt));\nrequire(commitment == commitments[msg.sender], \"Invalid reveal\");\nrequire(msg.value == amount, \"Amount mismatch\");\n\nbids[msg.sender] = amount;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Reward distribution logic detected - verify precision and rounding",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Common reward distribution errors:\n\n1. Integer division truncation:\n\u274c reward = balance / users;  // Loses remainder\n\u2705 reward = balance * 1e18 / users / 1e18;\n\n2. Accumulating rounding errors:\n\u274c Track individual rewards that sum != total\n\u2705 Use lastUser = total - sum(others)\n\n3. Division before multiplication:\n\u274c (balance / total) * multiplier\n\u2705 (balance * multiplier) / total\n\n4. Missing remainder handling:\nuint256 perUser = total / userCount;\nuint256 remainder = total % userCount;\n// Handle remainder explicitly!",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Array access without length validation - can cause out-of-bounds access",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n\u2705 VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n\u2705 VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-access-control",
        "message": "tx.origin used in access control - vulnerable to phishing attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c NEVER use tx.origin for access control:\nfunction withdraw() public {\nrequire(tx.origin == owner, \"Not owner\");\n// Vulnerable to phishing!\n}\n\nAttack scenario:\n1. Attacker deploys malicious contract\n2. Owner calls attacker contract\n3. Attacker contract calls victim.withdraw()\n4. tx.origin is still owner, check passes!\n5. Funds drained\n\n\u2705 ALWAYS use msg.sender:\nfunction withdraw() public {\nrequire(msg.sender == owner, \"Not owner\");\n// Safe: msg.sender is immediate caller\n}\n\nThe difference:\n- msg.sender: Immediate caller (can be contract)\n- tx.origin: Original EOA that started the transaction\n\nValid use of tx.origin:\n- Reject contract calls: require(tx.origin == msg.sender)\n- But NEVER for access control decisions",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3146
        },
        "fix_suggestion": {
          "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'claimReward' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'claimReward' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'claimReward' does not check return value",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 62,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'claimReward' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'claimReward' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'claimReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'claimReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'claimReward' contains variable shadowing. Parameter 'attackerAddress' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'claimReward'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation doesn't account for totalSupply in 'claimReward'",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate rewards: rewardPerToken = (rewardRate * timeDelta * 1e18) / totalSupply;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No timestamp tracking for reward accrual in 'claimReward'",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Missing reward debt tracking (double-claim risk) in 'claimReward'",
        "severity": "critical",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation without precision multiplier (rounding errors) in 'claimReward'",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors",
          "replacements": []
        }
      },
      {
        "detector_id": "diamond-storage-collision",
        "message": "Contract 'PhishingAttacker' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
        "severity": "critical",
        "location": {
          "line": 58,
          "column": 10,
          "length": 16
        },
        "cwe": "CWE-1321",
        "fix_suggestion": {
          "description": "Implement Diamond Storage pattern for 'PhishingAttacker': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.phishingattacker\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'setBeneficiary' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 101,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'setBeneficiary'",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 97,
          "column": 9,
          "length": 52
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_beneficiary' in function 'setBeneficiary' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 101,
          "column": 37,
          "length": 12
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_beneficiary != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_beneficiary' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 101,
          "column": 37,
          "length": 12
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_beneficiary != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'endAuction' does not check return value",
        "severity": "medium",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'endAuction'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 84,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "block-stuffing-vulnerable",
        "message": "Function 'endAuction' is vulnerable to block stuffing attacks. Auction closes in single block without multi-block finalization period, vulnerable to block stuffing to prevent last-minute bids Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.",
        "severity": "high",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate block stuffing in 'endAuction'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'bid' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 88,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'bid'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'endAuction' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'endAuction'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'endAuction' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'endAuction'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "front-running-mitigation",
        "message": "Function 'bid' lacks front-running protection. Bidding function 'bid' lacks commit-reveal scheme. Attackers can see your bid and outbid you Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
        "severity": "high",
        "location": {
          "line": 88,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add front-running protection to 'bid'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'bid' contains variable shadowing. Parameter 'highestBid' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 88,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'bid'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'endAuction' contains variable shadowing. Parameter 'beneficiary' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'endAuction'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Classic reentrancy pattern with transient storage risk in 'endAuction'",
        "severity": "critical",
        "location": {
          "line": 95,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() \u2190 attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 \u2190 do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "DelegateCall",
    "total_findings": 89,
    "critical": 30,
    "high": 43,
    "medium": 8,
    "low": 8,
    "detectors": {
      "missing-zero-address-check": 3,
      "parameter-consistency": 5,
      "test-governance": 9,
      "storage-collision": 4,
      "dangerous-delegatecall": 7,
      "upgradeable-proxy-issues": 5,
      "circular-dependency": 6,
      "inefficient-storage": 2,
      "centralization-risk": 1,
      "deprecated-functions": 1,
      "aa-initialization-vulnerability": 7,
      "hardware-wallet-delegation": 2,
      "floating-pragma": 1,
      "diamond-storage-collision": 3,
      "multisig-bypass": 1,
      "eip7702-delegate-access-control": 2,
      "eip7702-storage-collision": 1,
      "logic-error-patterns": 1,
      "enhanced-input-validation": 3,
      "enhanced-access-control": 1,
      "jit-liquidity-sandwich": 2,
      "pool-donation-enhanced": 1,
      "missing-access-modifiers": 7,
      "selfdestruct-abuse": 2,
      "mev-extractable-value": 4,
      "vault-withdrawal-dos": 2,
      "validator-front-running": 1,
      "lending-borrow-bypass": 1,
      "unprotected-initializer": 1,
      "invalid-state-transition": 1,
      "excessive-gas-usage": 1,
      "eip7702-init-frontrun": 1
    },
    "findings": [
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_target' in function 'execute' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 29,
          "column": 30,
          "length": 7
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_target != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_target' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 29,
          "column": 30,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_target != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 15,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Function 'execute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
        "severity": "medium",
        "location": {
          "line": 29,
          "column": 0,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Implement time-delayed voting rights requiring minimum holding periods.",
          "replacements": []
        }
      },
      {
        "detector_id": "storage-collision",
        "message": "Function 'forward' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.",
        "severity": "critical",
        "location": {
          "line": 21,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Ensure storage layout compatibility in 'forward'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.",
          "replacements": []
        }
      },
      {
        "detector_id": "storage-collision",
        "message": "Function 'execute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.",
        "severity": "critical",
        "location": {
          "line": 29,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Ensure storage layout compatibility in 'execute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function 'forward' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 21,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in 'forward'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function 'execute' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 29,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in 'execute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "upgradeable-proxy-issues",
        "message": "Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
        "severity": "critical",
        "location": {
          "line": 15,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-665",
        "fix_suggestion": {
          "description": "Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
          "replacements": []
        }
      },
      {
        "detector_id": "upgradeable-proxy-issues",
        "message": "Function 'forward' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
        "severity": "critical",
        "location": {
          "line": 21,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-665",
        "fix_suggestion": {
          "description": "Fix proxy implementation in 'forward'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'forward' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 21,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'forward'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'execute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 29,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'execute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 148,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 157,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "deprecated-functions",
        "message": "Deprecated function or pattern detected: 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns",
        "severity": "low",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-477",
        "fix_suggestion": {
          "description": "Replace deprecated 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.",
        "severity": "high",
        "location": {
          "line": 157,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-306",
        "fix_suggestion": {
          "description": "Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
        "severity": "high",
        "location": {
          "line": 16,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
        "severity": "high",
        "location": {
          "line": 46,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.",
        "severity": "high",
        "location": {
          "line": 38,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.",
        "severity": "high",
        "location": {
          "line": 76,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.",
        "severity": "high",
        "location": {
          "line": 109,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.",
          "replacements": []
        }
      },
      {
        "detector_id": "hardware-wallet-delegation",
        "message": "Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-672",
        "fix_suggestion": {
          "description": "Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "hardware-wallet-delegation",
        "message": "Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "diamond-storage-collision",
        "message": "Contract 'VulnerableProxy' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
        "severity": "critical",
        "location": {
          "line": 11,
          "column": 10,
          "length": 15
        },
        "cwe": "CWE-1321",
        "fix_suggestion": {
          "description": "Implement Diamond Storage pattern for 'VulnerableProxy': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.vulnerableproxy\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
          "replacements": []
        }
      },
      {
        "detector_id": "multisig-bypass",
        "message": "Signatures without expiration/deadline (indefinite validity risk)",
        "severity": "medium",
        "location": {
          "line": 0,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, \"Signature expired\"); Prevents execution of stale signatures.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'execute' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 29,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-storage-collision",
        "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Array access without length validation - can cause out-of-bounds access",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n\u2705 VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n\u2705 VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-access-control",
        "message": "Single-step ownership transfer - use 2-step transfer to prevent mistakes",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c DANGEROUS - Single-step ownership transfer:\nfunction transferOwnership(address newOwner) public onlyOwner {\nowner = newOwner;  // What if newOwner is wrong address?\n}\n// Risk: Typo in address = permanent loss of control\n\n\u2705 SAFE - Two-step ownership transfer:\naddress public owner;\naddress public pendingOwner;\n\n// Step 1: Current owner nominates new owner\nfunction transferOwnership(address newOwner) public onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\npendingOwner = newOwner;\nemit OwnershipTransferStarted(owner, newOwner);\n}\n\n// Step 2: New owner must accept\nfunction acceptOwnership() public {\nrequire(msg.sender == pendingOwner, \"Not pending owner\");\naddress oldOwner = owner;\nowner = pendingOwner;\npendingOwner = address(0);\nemit OwnershipTransferred(oldOwner, owner);\n}\n\n\u2705 BEST - Use OpenZeppelin Ownable2Step:\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\ncontract MyContract is Ownable2Step {\n// Automatically has 2-step transfer\n}\n\nBenefits of 2-step:\n- New owner must prove they control the address\n- Prevents typos in addresses\n- Allows cancellation before acceptance\n- New owner can verify contract state first",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5038
        },
        "fix_suggestion": {
          "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5038
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5038
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'becomeOwner' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 45,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'becomeOwner'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'destroy' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 49,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'destroy'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 45,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "selfdestruct-abuse",
        "message": "Function 'destroy' contains selfdestruct abuse vulnerability. Selfdestruct is publicly accessible without access control, allowing anyone to destroy the contract Selfdestruct permanently destroys the contract and can force-send ether to any address, bypassing fallback functions and breaking assumptions.",
        "severity": "high",
        "location": {
          "line": 49,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-670",
        "fix_suggestion": {
          "description": "Restrict or remove selfdestruct in 'destroy'. Add access control (onlyOwner), implement time-lock, or use withdraw pattern instead of selfdestruct. Consider that contracts expecting ether may not have payable fallback.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'becomeOwner' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 45,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'becomeOwner'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'destroy' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 49,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'destroy'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'withdraw' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 73,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'withdraw'",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 73,
          "column": 31,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 63,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "storage-collision",
        "message": "Function 'withdraw' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.",
        "severity": "critical",
        "location": {
          "line": 73,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Ensure storage layout compatibility in 'withdraw'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function 'withdraw' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 73,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in 'withdraw'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 82,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdraw' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 73,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'withdraw' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 73,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'withdraw'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'withdraw' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 73,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'withdraw'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function '' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 82,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in ''. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "diamond-storage-collision",
        "message": "Contract 'VulnerableWallet' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
        "severity": "critical",
        "location": {
          "line": 58,
          "column": 10,
          "length": 16
        },
        "cwe": "CWE-1321",
        "fix_suggestion": {
          "description": "Implement Diamond Storage pattern for 'VulnerableWallet': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.vulnerablewallet\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'withdraw' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 96,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'withdraw'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'setOwner' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 102,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'setOwner'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_newOwner' in function 'setOwner' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 102,
          "column": 31,
          "length": 9
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_newOwner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 96,
          "column": 31,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_newOwner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 102,
          "column": 31,
          "length": 9
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_newOwner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 96,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdraw' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 96,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'withdraw' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 96,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'withdraw'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "lending-borrow-bypass",
        "message": "Lending protocol function 'withdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
        "severity": "critical",
        "location": {
          "line": 96,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Secure lending function 'withdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 115,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Function 'executeLogic' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
        "severity": "medium",
        "location": {
          "line": 124,
          "column": 0,
          "length": 12
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Implement time-delayed voting rights requiring minimum holding periods.",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function 'executeLogic' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 124,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in 'executeLogic'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'register' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 119,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'register'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'executeLogic' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 124,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'executeLogic'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "diamond-storage-collision",
        "message": "Contract 'VulnerableRegistry' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
        "severity": "critical",
        "location": {
          "line": 111,
          "column": 10,
          "length": 18
        },
        "cwe": "CWE-1321",
        "fix_suggestion": {
          "description": "Implement Diamond Storage pattern for 'VulnerableRegistry': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.vulnerableregistry\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'executeLogic' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 124,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'destroy' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 135,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'destroy'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 135,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function 'destroy' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 135,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in 'destroy'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "selfdestruct-abuse",
        "message": "Function 'destroy' contains selfdestruct abuse vulnerability. Selfdestruct is publicly accessible without access control, allowing anyone to destroy the contract Selfdestruct permanently destroys the contract and can force-send ether to any address, bypassing fallback functions and breaking assumptions.",
        "severity": "high",
        "location": {
          "line": 135,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-670",
        "fix_suggestion": {
          "description": "Restrict or remove selfdestruct in 'destroy'. Add access control (onlyOwner), implement time-lock, or use withdraw pattern instead of selfdestruct. Consider that contracts expecting ether may not have payable fallback.",
          "replacements": []
        }
      },
      {
        "detector_id": "upgradeable-proxy-issues",
        "message": "Function 'destroy' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
        "severity": "critical",
        "location": {
          "line": 135,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-665",
        "fix_suggestion": {
          "description": "Fix proxy implementation in 'destroy'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'initialize' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 157,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'initialize'",
          "replacements": []
        }
      },
      {
        "detector_id": "unprotected-initializer",
        "message": "Initializer function 'initialize' lacks access control and can be called by anyone",
        "severity": "high",
        "location": {
          "line": 157,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier to 'initialize' or ensure it can only be called once during deployment",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variable 'initialized' is modified without proper validation or state checks",
        "severity": "high",
        "location": {
          "line": 160,
          "column": 9,
          "length": 18
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add proper validation before modifying state variables",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_owner' in function 'initialize' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 157,
          "column": 33,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_owner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_owner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 157,
          "column": 33,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_owner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 151,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "storage-collision",
        "message": "Function '' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.",
        "severity": "critical",
        "location": {
          "line": 163,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 163,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "upgradeable-proxy-issues",
        "message": "Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
        "severity": "critical",
        "location": {
          "line": 151,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-665",
        "fix_suggestion": {
          "description": "Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
          "replacements": []
        }
      },
      {
        "detector_id": "upgradeable-proxy-issues",
        "message": "Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
        "severity": "critical",
        "location": {
          "line": 163,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-665",
        "fix_suggestion": {
          "description": "Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function '' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 163,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in ''. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 157,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-init-frontrun",
        "message": "Unprotected initialization in 'initialize' - vulnerable to front-running takeover ($1.54M August 2025 attack)",
        "severity": "critical",
        "location": {
          "line": 157,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-7702 Front-Running Attack:\n\nCurrent code (VULNERABLE):\nfunction initialize(...) public {\nrequire(owner == address(0));\nowner = newOwner;  // \u274c Attacker can front-run!\n}\n\nAttack sequence:\n1. User signs EIP-7702 authorization\n2. Attacker sees authorization in mempool\n3. Attacker front-runs with initialize(attackerAddress)\n4. User's delegation is now controlled by attacker\n5. Attacker drains all assets\n\nFix 1: Authorization-based initialization\nfunction initialize(address _owner, bytes memory signature) public {\nrequire(owner == address(0));\n\n// \u2705 Verify user signed this specific initialization\nbytes32 hash = keccak256(abi.encodePacked(_owner, address(this)));\naddress signer = ECDSA.recover(hash, signature);\nrequire(signer == _owner, \"Invalid signature\");\n\nowner = _owner;\n}\n\nFix 2: Constructor initialization (if possible)\nconstructor(address _owner) {\nowner = _owner;  // \u2705 Set during deployment\n}\n\nFix 3: Factory pattern with immediate initialization\ncontract DelegateFactory {\nfunction createDelegate() public returns (address) {\nDelegate delegate = new Delegate(msg.sender);\nreturn address(delegate);\n}\n}\n\nFix 4: Commit-reveal with time-lock\nmapping(bytes32 => uint256) public commitments;\n\nfunction commitInit(bytes32 commitment) public {\ncommitments[commitment] = block.timestamp;\n}\n\nfunction initialize(address _owner, bytes32 salt) public {\nbytes32 commitment = keccak256(abi.encodePacked(_owner, salt));\nrequire(commitments[commitment] > 0, \"No commitment\");\nrequire(block.timestamp >= commitments[commitment] + 10 minutes);\n\nowner = _owner;\n}\n\nReal-World Loss: $1.54M (August 2025)",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "DenialOfService",
    "total_findings": 49,
    "critical": 6,
    "high": 20,
    "medium": 14,
    "low": 9,
    "detectors": {
      "block-stuffing-vulnerable": 1,
      "mev-extractable-value": 4,
      "gas-griefing": 3,
      "front-running-mitigation": 1,
      "shadowing-variables": 4,
      "erc20-transfer-return-bomb": 1,
      "floating-pragma": 1,
      "missing-commit-reveal": 1,
      "logic-error-patterns": 1,
      "enhanced-input-validation": 1,
      "missing-access-modifiers": 4,
      "classic-reentrancy": 2,
      "missing-zero-address-check": 2,
      "parameter-consistency": 2,
      "single-oracle-source": 3,
      "unchecked-external-call": 3,
      "external-calls-loop": 2,
      "validator-front-running": 1,
      "dos-unbounded-operation": 4,
      "excessive-gas-usage": 6,
      "transient-storage-reentrancy": 2
    },
    "findings": [
      {
        "detector_id": "block-stuffing-vulnerable",
        "message": "Function 'bid' is vulnerable to block stuffing attacks. Auction closes in single block without multi-block finalization period, vulnerable to block stuffing to prevent last-minute bids Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.",
        "severity": "high",
        "location": {
          "line": 15,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate block stuffing in 'bid'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'bid' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 15,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'bid'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'bid' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 15,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'bid'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "front-running-mitigation",
        "message": "Function 'bid' lacks front-running protection. Bidding function 'bid' lacks commit-reveal scheme. Attackers can see your bid and outbid you Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
        "severity": "high",
        "location": {
          "line": 15,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add front-running protection to 'bid'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'bid' contains variable shadowing. Parameter 'currentBid' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 15,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'bid'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3817
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-commit-reveal",
        "message": "Auction/bidding without commit-reveal - bids can be front-run",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Implement commit-reveal pattern:\n\nmapping(address => bytes32) public commitments;\nmapping(address => uint256) public bids;\nuint256 public commitDeadline;\nuint256 public revealDeadline;\n\n// Phase 1: Commit (hide bid amount)\nfunction commitBid(bytes32 commitment) external {\nrequire(block.timestamp < commitDeadline);\ncommitments[msg.sender] = commitment;\n}\n\n// Phase 2: Reveal (after commit deadline)\nfunction revealBid(uint256 amount, bytes32 salt) external payable {\nrequire(block.timestamp >= commitDeadline);\nrequire(block.timestamp < revealDeadline);\n\nbytes32 commitment = keccak256(abi.encode(amount, salt));\nrequire(commitment == commitments[msg.sender], \"Invalid reveal\");\nrequire(msg.value == amount, \"Amount mismatch\");\n\nbids[msg.sender] = amount;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'addShareholder' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 36,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'addShareholder'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'distributeRewards' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'distributeRewards'",
          "replacements": []
        }
      },
      {
        "detector_id": "classic-reentrancy",
        "message": "Function 'addShareholder' may be vulnerable to reentrancy attacks due to state changes after external calls",
        "severity": "high",
        "location": {
          "line": 36,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Apply checks-effects-interactions pattern or use a reentrancy guard in function 'addShareholder'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_shareholder' in function 'addShareholder' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 36,
          "column": 37,
          "length": 12
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_shareholder != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_shareholder' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 36,
          "column": 37,
          "length": 12
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_shareholder != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'addShareholder' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 36,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'addShareholder'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'addShareholder' does not check return value",
        "severity": "medium",
        "location": {
          "line": 36,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'addShareholder'",
          "replacements": []
        }
      },
      {
        "detector_id": "external-calls-loop",
        "message": "Function 'distributeRewards' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.",
        "severity": "high",
        "location": {
          "line": 42,
          "column": 0,
          "length": 17
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'distributeRewards' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 42,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'distributeRewards'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'distributeRewards' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 42,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'distributeRewards'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'distributeRewards' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 42,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'distributeRewards'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'distributeRewards' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 42,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'distributeRewards'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'distributeRewards' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 42,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'distributeRewards'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'distributeRewards' contains variable shadowing. Local variable 'totalShares' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 42,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'distributeRewards'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'distributeRewards' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'reset' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 72,
          "column": 14,
          "length": 5
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'reset'",
          "replacements": []
        }
      },
      {
        "detector_id": "classic-reentrancy",
        "message": "Function 'register' may be vulnerable to reentrancy attacks due to state changes after external calls",
        "severity": "high",
        "location": {
          "line": 65,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Apply checks-effects-interactions pattern or use a reentrancy guard in function 'register'",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'register' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 65,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'register'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'register' does not check return value",
        "severity": "medium",
        "location": {
          "line": 65,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'register'",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'register' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 65,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'register'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'reset' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 72,
          "column": 14,
          "length": 5
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'reset'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'getUserCount' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 81,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'getUserCount'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'reset' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 72,
          "column": 14,
          "length": 5
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'reset'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'reset' contains excessive gas usage pattern. Storage deletion inside loop. Each delete costs significant gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 72,
          "column": 14,
          "length": 5
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'reset'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'reset' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 72,
          "column": 14,
          "length": 5
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'reset'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'getUserCount' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 81,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'getUserCount'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'getUserCount' contains variable shadowing. Local variable 'count' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 81,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'getUserCount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'addRecipient' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 100,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'addRecipient'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_recipient' in function 'addRecipient' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 100,
          "column": 35,
          "length": 10
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_recipient != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_recipient' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 100,
          "column": 35,
          "length": 10
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_recipient != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'addRecipient' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 100,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'addRecipient'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'addRecipient' does not check return value",
        "severity": "medium",
        "location": {
          "line": 100,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'addRecipient'",
          "replacements": []
        }
      },
      {
        "detector_id": "external-calls-loop",
        "message": "Function 'splitPayment' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.",
        "severity": "high",
        "location": {
          "line": 105,
          "column": 0,
          "length": 12
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'splitPayment' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 105,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'splitPayment'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'splitPayment' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 105,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'splitPayment'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'splitPayment' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 105,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'splitPayment'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'splitPayment' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 105,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'splitPayment'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'splitPayment' contains variable shadowing. Local variable 'share' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 105,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'splitPayment'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'splitPayment' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 105,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "FrontRunning",
    "total_findings": 69,
    "critical": 8,
    "high": 25,
    "medium": 23,
    "low": 13,
    "detectors": {
      "invalid-state-transition": 1,
      "unchecked-external-call": 1,
      "mev-extractable-value": 5,
      "validator-front-running": 2,
      "gas-griefing": 2,
      "inefficient-storage": 6,
      "centralization-risk": 1,
      "insufficient-randomness": 1,
      "erc20-transfer-return-bomb": 1,
      "token-decimal-confusion": 1,
      "mev-toxic-flow-exposure": 4,
      "amm-k-invariant-violation": 4,
      "floating-pragma": 1,
      "logic-error-patterns": 2,
      "oracle-time-window-attack": 1,
      "enhanced-input-validation": 4,
      "jit-liquidity-sandwich": 1,
      "yield-farming-manipulation": 1,
      "pool-donation-enhanced": 2,
      "amm-invariant-manipulation": 2,
      "parameter-consistency": 6,
      "price-impact-manipulation": 2,
      "sandwich-resistant-swap": 2,
      "front-running-mitigation": 2,
      "shadowing-variables": 5,
      "defi-liquidity-pool-manipulation": 4,
      "defi-yield-farming-exploits": 3,
      "excessive-gas-usage": 1,
      "erc20-approve-race": 1
    },
    "findings": [
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 30,
          "column": 9,
          "length": 36
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'submitSolution' does not check return value",
        "severity": "medium",
        "location": {
          "line": 23,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'submitSolution'",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'submitSolution' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 23,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'submitSolution'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'submitSolution' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 23,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'submitSolution'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'submitSolution' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 23,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'submitSolution'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 15,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 43,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 44,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 83,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'updatePrice' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 92,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'transferFrom' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 136,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "insufficient-randomness",
        "message": "Function 'submitSolution' uses weak randomness source. Uses user address in randomness without commitment scheme. Users can predict outcomes and selectively participate Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
        "severity": "high",
        "location": {
          "line": 23,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-338",
        "fix_suggestion": {
          "description": "Use secure randomness in 'submitSolution'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "token-decimal-confusion",
        "message": "Token price/exchange calculation without decimal normalization - incorrect conversions",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-toxic-flow-exposure",
        "message": "Static fees on AMM - no protection against toxic flow from informed traders",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Implement dynamic fees that increase with volatility or trade size to discourage toxic flow",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-toxic-flow-exposure",
        "message": "No trade size limits - large informed trades can extract maximum value from LPs",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Add maximum trade size as percentage of reserves: require(amountIn < reserves * maxBps / 10000)",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-toxic-flow-exposure",
        "message": "Instant arbitrage possible - informed traders can extract value with zero risk",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Add block delay or use time-weighted pricing to reduce instant arbitrage opportunities",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-toxic-flow-exposure",
        "message": "Swaps don't check oracle price - no protection against informed traders exploiting price deviations",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Compare swap price against TWAP oracle; reject if deviation exceeds threshold",
          "replacements": []
        }
      },
      {
        "detector_id": "amm-k-invariant-violation",
        "message": "AMM function 'submitSolution' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage",
        "severity": "critical",
        "location": {
          "line": 23,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Secure AMM function 'submitSolution': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Reward distribution logic detected - verify precision and rounding",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Common reward distribution errors:\n\n1. Integer division truncation:\n\u274c reward = balance / users;  // Loses remainder\n\u2705 reward = balance * 1e18 / users / 1e18;\n\n2. Accumulating rounding errors:\n\u274c Track individual rewards that sum != total\n\u2705 Use lastUser = total - sum(others)\n\n3. Division before multiplication:\n\u274c (balance / total) * multiplier\n\u2705 (balance * multiplier) / total\n\n4. Missing remainder handling:\nuint256 perUser = total / userCount;\nuint256 remainder = total % userCount;\n// Handle remainder explicitly!",
          "replacements": []
        }
      },
      {
        "detector_id": "oracle-time-window-attack",
        "message": "Oracle price usage without time-weighted average - consider TWAP",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Single-block price oracles are manipulable:\n\n\u274c Vulnerable patterns:\n- Using spot price from DEX\n- Single block price snapshot\n- No time-weighting\n- No price deviation checks\n\n\u2705 Recommended solutions:\n\n1. Use Uniswap V3 TWAP (30+ minute window)\n2. Use Chainlink Price Feeds (aggregated off-chain)\n3. Combine multiple oracle sources\n4. Implement price deviation bounds:\nrequire(abs(newPrice - lastPrice) < maxDelta);\n5. Use time-weighted moving average:\npriceSum += currentPrice;\npriceCount++;\navgPrice = priceSum / priceCount;\n\nMinimum TWAP window: 30 minutes (longer is better)\nMaximum price deviation: 2-5% from last update",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Array access without length validation - can cause out-of-bounds access",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n\u2705 VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n\u2705 VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Percentage/fee parameter without bounds validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c UNBOUNDED PERCENTAGE:\nfunction setFee(uint256 newFee) external {\nfee = newFee;  // Could be set to 100% or higher!\n}\n\n\u2705 VALIDATE PERCENTAGE BOUNDS:\nuint256 public constant MAX_FEE = 1000;  // 10% in basis points\nuint256 public constant BASIS_POINTS = 10000;  // 100%\n\nfunction setFee(uint256 newFee) external onlyOwner {\nrequire(newFee <= MAX_FEE, \"Fee too high\");\nfee = newFee;\n}\n\n\u2705 COMPREHENSIVE RATIO VALIDATION:\nfunction setCollateralRatio(uint256 ratio) external {\n// Must be between 110% and 200%\nuint256 MIN_RATIO = 11000;  // 110%\nuint256 MAX_RATIO = 20000;  // 200%\n\nrequire(ratio >= MIN_RATIO, \"Ratio too low\");\nrequire(ratio <= MAX_RATIO, \"Ratio too high\");\ncollateralRatio = ratio;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "yield-farming-manipulation",
        "message": "No minimum staking duration enforced - allows instant reward farming",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Add minimum staking duration requirement before allowing reward claims",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "amm-invariant-manipulation",
        "message": "Price oracle uses spot price without TWAP - vulnerable to flash loan price manipulation",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Implement time-weighted average price (TWAP) using cumulative price observations to resist manipulation",
          "replacements": []
        }
      },
      {
        "detector_id": "amm-invariant-manipulation",
        "message": "Swap function supports callbacks without reentrancy guard - vulnerable to reentrancy via flash swaps",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 4954
        },
        "fix_suggestion": {
          "description": "Add reentrancy guard to swap function or validate invariants before and after callback execution",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_tokenAAmount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 56,
          "column": 32,
          "length": 13
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_tokenAAmount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "price-impact-manipulation",
        "message": "Function 'getSwapAmount' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
        "severity": "high",
        "location": {
          "line": 47,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Add price impact protection to 'getSwapAmount'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
          "replacements": []
        }
      },
      {
        "detector_id": "price-impact-manipulation",
        "message": "Function 'swapAforB' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
        "severity": "high",
        "location": {
          "line": 56,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Add price impact protection to 'swapAforB'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
          "replacements": []
        }
      },
      {
        "detector_id": "sandwich-resistant-swap",
        "message": "Function 'getSwapAmount' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
        "severity": "high",
        "location": {
          "line": 47,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add sandwich attack protection to 'getSwapAmount'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
          "replacements": []
        }
      },
      {
        "detector_id": "sandwich-resistant-swap",
        "message": "Function 'swapAforB' lacks sandwich attack protection. No deadline parameter to prevent delayed execution, allowing validators to hold and execute swap at unfavorable prices MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
        "severity": "high",
        "location": {
          "line": 56,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add sandwich attack protection to 'swapAforB'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'swapAforB' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 56,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'swapAforB'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'deposit' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 71,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'deposit'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'swapAforB' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 56,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'swapAforB'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'swapAforB' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 56,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'swapAforB'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "front-running-mitigation",
        "message": "Function 'swapAforB' lacks front-running protection. Trading function 'swapAforB' missing slippage protection (minAmountOut). Vulnerable to sandwich attacks Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
        "severity": "high",
        "location": {
          "line": 56,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add front-running protection to 'swapAforB'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'getSwapAmount' contains variable shadowing. Local variable 'k' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 47,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'getSwapAmount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'getSwapAmount' contains variable shadowing. Local variable 'newTokenAReserve' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 47,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'getSwapAmount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'getSwapAmount' contains variable shadowing. Local variable 'newTokenBReserve' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 47,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'getSwapAmount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-liquidity-pool-manipulation",
        "message": "No reentrancy protection (flash loan attack risk) in 'getSwapAmount'",
        "severity": "critical",
        "location": {
          "line": 47,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-liquidity-pool-manipulation",
        "message": "Missing deadline parameter (stuck transaction risk) in 'getSwapAmount'",
        "severity": "medium",
        "location": {
          "line": 47,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add deadline: require(block.timestamp <= deadline, \"Transaction expired\");",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-liquidity-pool-manipulation",
        "message": "No reentrancy protection (flash loan attack risk) in 'swapAforB'",
        "severity": "critical",
        "location": {
          "line": 56,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-liquidity-pool-manipulation",
        "message": "Missing deadline parameter (stuck transaction risk) in 'swapAforB'",
        "severity": "medium",
        "location": {
          "line": 56,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add deadline: require(block.timestamp <= deadline, \"Transaction expired\");",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No first depositor protection (inflation attack on vault initialization) in 'deposit'",
        "severity": "critical",
        "location": {
          "line": 71,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Lock initial shares: if (totalSupply() == 0) { _mint(address(0), INITIAL_SHARES); }",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No deposit cap (unlimited exposure risk) in 'deposit'",
        "severity": "low",
        "location": {
          "line": 71,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add cap: require(totalAssets() + amount <= depositCap, \"Cap exceeded\");",
          "replacements": []
        }
      },
      {
        "detector_id": "amm-k-invariant-violation",
        "message": "AMM function 'getSwapAmount' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV",
        "severity": "critical",
        "location": {
          "line": 47,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Secure AMM function 'getSwapAmount': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
          "replacements": []
        }
      },
      {
        "detector_id": "amm-k-invariant-violation",
        "message": "AMM function 'swapAforB' violates constant product invariant: Swap lacks deadline parameter, transactions may execute at unfavorable prices if delayed",
        "severity": "critical",
        "location": {
          "line": 56,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Secure AMM function 'swapAforB': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_newPrice' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 92,
          "column": 34,
          "length": 9
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add appropriate range validation for _newPrice",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'updatePrice' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 92,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'updatePrice'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "front-running-mitigation",
        "message": "Function 'buyTokens' lacks front-running protection. Trading function 'buyTokens' missing slippage protection (minAmountOut). Vulnerable to sandwich attacks Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
        "severity": "high",
        "location": {
          "line": 98,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add front-running protection to 'buyTokens'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'updatePrice' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 92,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'updatePrice'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'buyTokens' contains variable shadowing. Parameter 'tokensAvailable' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 98,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'buyTokens'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward update doesn't handle zero totalSupply (division by zero) in 'updatePrice'",
        "severity": "high",
        "location": {
          "line": 92,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Handle zero: if (totalSupply() > 0) { rewardPerToken = ...; }",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_spender' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 125,
          "column": 30,
          "length": 8
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_spender != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 125,
          "column": 48,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_from' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 136,
          "column": 35,
          "length": 5
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_from != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_to' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 136,
          "column": 50,
          "length": 3
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_to != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'approve' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 125,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'approve'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'transferFrom' contains excessive gas usage pattern. Multiple storage reads detected (9). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 136,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'transferFrom'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-approve-race",
        "message": "Function 'approve' has approve race condition vulnerability. Standard ERC-20 approve without race condition protection Vulnerable to front-running attack (SWC-114).",
        "severity": "medium",
        "location": {
          "line": 125,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Fix 'approve' race condition. Solutions: (1) Require current allowance == 0 before changes, (2) Use increaseAllowance/decreaseAllowance pattern, (3) Add expectedCurrentValue parameter",
          "replacements": []
        }
      },
      {
        "detector_id": "amm-k-invariant-violation",
        "message": "AMM function 'approve' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage",
        "severity": "critical",
        "location": {
          "line": 125,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Secure AMM function 'approve': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "IntegerOverflow",
    "total_findings": 58,
    "critical": 6,
    "high": 23,
    "medium": 19,
    "low": 10,
    "detectors": {
      "parameter-consistency": 4,
      "integer-overflow": 8,
      "vault-withdrawal-dos": 2,
      "validator-front-running": 1,
      "token-supply-manipulation": 1,
      "gas-griefing": 2,
      "excessive-gas-usage": 4,
      "inefficient-storage": 2,
      "centralization-risk": 1,
      "shadowing-variables": 2,
      "unchecked-math": 4,
      "erc20-transfer-return-bomb": 1,
      "token-decimal-confusion": 1,
      "defi-yield-farming-exploits": 9,
      "lending-borrow-bypass": 2,
      "floating-pragma": 1,
      "logic-error-patterns": 2,
      "enhanced-input-validation": 2,
      "post-080-overflow": 1,
      "jit-liquidity-sandwich": 2,
      "yield-farming-manipulation": 1,
      "pool-donation-enhanced": 2,
      "invalid-state-transition": 1,
      "unchecked-external-call": 1,
      "vault-hook-reentrancy": 1
    },
    "findings": [
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_to' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 22,
          "column": 31,
          "length": 3
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_to != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_receivers' of type 'array' may need validation",
        "severity": "medium",
        "location": {
          "line": 31,
          "column": 45,
          "length": 10
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_receivers.length > 0, \"Array cannot be empty\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_value' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 31,
          "column": 65,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add appropriate range validation for _value",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'transfer' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs addition, subtraction without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.",
        "severity": "high",
        "location": {
          "line": 22,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Use SafeMath library in 'transfer' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'batchTransfer' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs addition, subtraction, multiplication without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.",
        "severity": "high",
        "location": {
          "line": 31,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Use SafeMath library in 'batchTransfer' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'withdrawReward' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs subtraction without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.",
        "severity": "high",
        "location": {
          "line": 44,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Use SafeMath library in 'withdrawReward' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdrawReward' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 44,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdrawReward' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'withdrawReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 44,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'withdrawReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "token-supply-manipulation",
        "message": "Function '' has token supply manipulation vulnerability. Function directly modifies totalSupply variable, bypasses mint/burn controls for supply manipulation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation.",
        "severity": "critical",
        "location": {
          "line": 16,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Fix token supply controls in ''. Implement maximum supply cap, add minting rate limits, require multi-signature for minting, add supply change events, validate burn amounts, and implement supply monitoring.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'batchTransfer' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 31,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'batchTransfer'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'transfer' contains excessive gas usage pattern. Multiple storage reads detected (9). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 22,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'transfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'batchTransfer' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 31,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'batchTransfer' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 31,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'withdrawReward' contains excessive gas usage pattern. Multiple storage reads detected (4). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 44,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'withdrawReward'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'transfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 22,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'batchTransfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 31,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'batchTransfer' contains variable shadowing. Local variable 'count' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 31,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'batchTransfer'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'batchTransfer' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 31,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'batchTransfer'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-math",
        "message": "Function 'transfer' contains unchecked arithmetic operations. Pre-Solidity 0.8 arithmetic without SafeMath. No overflow protection Unchecked math can silently overflow/underflow leading to incorrect calculations and potential exploits.",
        "severity": "medium",
        "location": {
          "line": 22,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Remove unsafe unchecked blocks in 'transfer'. Solidity 0.8+ has built-in overflow protection. Only use 'unchecked' for gas optimization when overflow is mathematically impossible. Add explicit validation or use OpenZeppelin SafeMath for Solidity <0.8.",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-math",
        "message": "Function 'batchTransfer' contains unchecked arithmetic operations. Pre-Solidity 0.8 arithmetic without SafeMath. No overflow protection Unchecked math can silently overflow/underflow leading to incorrect calculations and potential exploits.",
        "severity": "medium",
        "location": {
          "line": 31,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Remove unsafe unchecked blocks in 'batchTransfer'. Solidity 0.8+ has built-in overflow protection. Only use 'unchecked' for gas optimization when overflow is mathematically impossible. Add explicit validation or use OpenZeppelin SafeMath for Solidity <0.8.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 2515
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "token-decimal-confusion",
        "message": "Decimal-sensitive math operations without validation - verify decimal assumptions",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 2515
        },
        "fix_suggestion": {
          "description": "Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No withdrawal fee accounting (fee bypass risk) in 'withdrawReward'",
        "severity": "medium",
        "location": {
          "line": 44,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Asset calculation missing totalSupply/totalAssets in 'withdrawReward'",
        "severity": "high",
        "location": {
          "line": 44,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No timestamp tracking for reward accrual in 'withdrawReward'",
        "severity": "high",
        "location": {
          "line": 44,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Missing reward debt tracking (double-claim risk) in 'withdrawReward'",
        "severity": "critical",
        "location": {
          "line": 44,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation without precision multiplier (rounding errors) in 'withdrawReward'",
        "severity": "medium",
        "location": {
          "line": 44,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors",
          "replacements": []
        }
      },
      {
        "detector_id": "lending-borrow-bypass",
        "message": "Lending protocol function 'withdrawReward' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
        "severity": "critical",
        "location": {
          "line": 44,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Secure lending function 'withdrawReward': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.7.6;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.7.6;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Reward distribution logic detected - verify precision and rounding",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Common reward distribution errors:\n\n1. Integer division truncation:\n\u274c reward = balance / users;  // Loses remainder\n\u2705 reward = balance * 1e18 / users / 1e18;\n\n2. Accumulating rounding errors:\n\u274c Track individual rewards that sum != total\n\u2705 Use lastUser = total - sum(others)\n\n3. Division before multiplication:\n\u274c (balance / total) * multiplier\n\u2705 (balance * multiplier) / total\n\n4. Missing remainder handling:\nuint256 perUser = total / userCount;\nuint256 remainder = total % userCount;\n// Handle remainder explicitly!",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "post-080-overflow",
        "message": "Unchecked block found - overflows/underflows won't revert (OWASP 2025)",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u26a0\ufe0f UNCHECKED BLOCKS BYPASS SOLIDITY 0.8.0+ PROTECTION!\n\nSolidity 0.8.0+ has automatic overflow/underflow checks,\nbut 'unchecked' blocks disable this protection.\n\n\u274c DANGEROUS if user input involved:\nunchecked {\nbalance += amount;  // Can overflow!\ntotal = a * b;      // Can overflow!\n}\n\n\u2705 SAFE usage (loop counters only):\nfor (uint256 i = 0; i < items.length;) {\n// Process items[i]\n\nunchecked {\n++i;  // Safe: loop counter can't realistically overflow\n}\n}\n\n\u2705 SAFE usage (guaranteed no overflow):\nunchecked {\n// Safe: subtraction after comparison\nif (a >= b) {\nresult = a - b;  // No underflow possible\n}\n}\n\n\u274c NEVER use unchecked for:\n- User-supplied values\n- Token amounts\n- Financial calculations\n- Multiplication of arbitrary values\n\nOnly use unchecked when:\n1. Loop counters (i++, ++i)\n2. Mathematically proven safe\n3. Gas optimization with careful review",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 2515
        },
        "fix_suggestion": {
          "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 2515
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "yield-farming-manipulation",
        "message": "No minimum staking duration enforced - allows instant reward farming",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 2515
        },
        "fix_suggestion": {
          "description": "Add minimum staking duration requirement before allowing reward claims",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 2515
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 2515
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 74,
          "column": 9,
          "length": 36
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter 'amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 69,
          "column": 41,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'vulnerableWithdraw' does not check return value",
        "severity": "medium",
        "location": {
          "line": 69,
          "column": 14,
          "length": 18
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'vulnerableWithdraw'",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'deposit' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs addition without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.",
        "severity": "high",
        "location": {
          "line": 57,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Use SafeMath library in 'deposit' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'unsafeMultiply' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs multiplication without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.",
        "severity": "high",
        "location": {
          "line": 62,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Use SafeMath library in 'unsafeMultiply' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'unsafeMultiply' contains unchecked arithmetic block. Unchecked block lacks safety justification comments Unchecked blocks bypass Solidity 0.8.0+ overflow protection, reintroducing overflow/underflow vulnerabilities.",
        "severity": "high",
        "location": {
          "line": 62,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Carefully review unchecked block in 'unsafeMultiply'. Only use unchecked for proven safe operations. Add require() statements to validate input ranges if needed.",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'vulnerableWithdraw' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs subtraction without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 18
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Use SafeMath library in 'vulnerableWithdraw' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'vulnerableWithdraw' contains unchecked arithmetic block. Unchecked block performs arithmetic on user-controlled values or critical state variables Unchecked blocks bypass Solidity 0.8.0+ overflow protection, reintroducing overflow/underflow vulnerabilities.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 18
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Carefully review unchecked block in 'vulnerableWithdraw'. Only use unchecked for proven safe operations. Add require() statements to validate input ranges if needed.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'vulnerableWithdraw' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 18
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'vulnerableWithdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-hook-reentrancy",
        "message": "Function 'vulnerableWithdraw' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 18
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'vulnerableWithdraw' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'vulnerableWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 69,
          "column": 14,
          "length": 18
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'vulnerableWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-math",
        "message": "Function 'unsafeMultiply' contains unchecked arithmetic operations. Unchecked multiplication detected. Multiplication can overflow without reversion Unchecked math can silently overflow/underflow leading to incorrect calculations and potential exploits.",
        "severity": "medium",
        "location": {
          "line": 62,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Remove unsafe unchecked blocks in 'unsafeMultiply'. Solidity 0.8+ has built-in overflow protection. Only use 'unchecked' for gas optimization when overflow is mathematically impossible. Add explicit validation or use OpenZeppelin SafeMath for Solidity <0.8.",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-math",
        "message": "Function 'unsafeMultiply' contains unchecked arithmetic operations. Pre-Solidity 0.8 arithmetic without SafeMath. No overflow protection Unchecked math can silently overflow/underflow leading to incorrect calculations and potential exploits.",
        "severity": "medium",
        "location": {
          "line": 62,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Remove unsafe unchecked blocks in 'unsafeMultiply'. Solidity 0.8+ has built-in overflow protection. Only use 'unchecked' for gas optimization when overflow is mathematically impossible. Add explicit validation or use OpenZeppelin SafeMath for Solidity <0.8.",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No first depositor protection (inflation attack on vault initialization) in 'deposit'",
        "severity": "critical",
        "location": {
          "line": 57,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Lock initial shares: if (totalSupply() == 0) { _mint(address(0), INITIAL_SHARES); }",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No deposit cap (unlimited exposure risk) in 'deposit'",
        "severity": "low",
        "location": {
          "line": 57,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add cap: require(totalAssets() + amount <= depositCap, \"Cap exceeded\");",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No withdrawal fee accounting (fee bypass risk) in 'vulnerableWithdraw'",
        "severity": "medium",
        "location": {
          "line": 69,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Asset calculation missing totalSupply/totalAssets in 'vulnerableWithdraw'",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
          "replacements": []
        }
      },
      {
        "detector_id": "lending-borrow-bypass",
        "message": "Lending protocol function 'vulnerableWithdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
        "severity": "critical",
        "location": {
          "line": 69,
          "column": 14,
          "length": 18
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Secure lending function 'vulnerableWithdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "Reentrancy",
    "total_findings": 20,
    "critical": 1,
    "high": 10,
    "medium": 6,
    "low": 3,
    "detectors": {
      "classic-reentrancy": 1,
      "vault-withdrawal-dos": 1,
      "circular-dependency": 1,
      "gas-griefing": 1,
      "excessive-gas-usage": 1,
      "inefficient-storage": 1,
      "centralization-risk": 1,
      "shadowing-variables": 2,
      "floating-pragma": 1,
      "transient-storage-reentrancy": 1,
      "logic-error-patterns": 1,
      "enhanced-input-validation": 2,
      "jit-liquidity-sandwich": 2,
      "pool-donation-enhanced": 2,
      "single-oracle-source": 1,
      "unchecked-external-call": 1
    },
    "findings": [
      {
        "detector_id": "classic-reentrancy",
        "message": "Function 'withdraw' may be vulnerable to reentrancy attacks due to state changes after external calls",
        "severity": "high",
        "location": {
          "line": 19,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Apply checks-effects-interactions pattern or use a reentrancy guard in function 'withdraw'",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 19,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'withdraw' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 19,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'withdraw'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'withdraw' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 19,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'withdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'withdraw' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 19,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'withdraw'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'withdraw' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 19,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'withdraw' contains variable shadowing. Parameter 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 19,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'withdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'withdraw' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 19,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'withdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'withdraw' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 19,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Array access without length validation - can cause out-of-bounds access",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n\u2705 VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n\u2705 VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 1913
        },
        "fix_suggestion": {
          "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 1913
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 1913
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 1913
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'attack' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 48,
          "column": 14,
          "length": 6
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'attack'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'attack' does not check return value",
        "severity": "medium",
        "location": {
          "line": 48,
          "column": 14,
          "length": 6
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'attack'",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "ShortAddress",
    "total_findings": 70,
    "critical": 6,
    "high": 29,
    "medium": 19,
    "low": 16,
    "detectors": {
      "parameter-consistency": 15,
      "mev-extractable-value": 3,
      "token-supply-manipulation": 1,
      "gas-griefing": 4,
      "excessive-gas-usage": 5,
      "inefficient-storage": 3,
      "centralization-risk": 1,
      "shadowing-variables": 2,
      "token-decimal-confusion": 2,
      "mev-priority-gas-auction": 1,
      "floating-pragma": 1,
      "multisig-bypass": 2,
      "eip7702-storage-collision": 1,
      "logic-error-patterns": 1,
      "enhanced-input-validation": 1,
      "post-080-overflow": 1,
      "jit-liquidity-sandwich": 2,
      "pool-donation-enhanced": 2,
      "missing-access-modifiers": 2,
      "missing-zero-address-check": 7,
      "array-bounds-check": 1,
      "vault-withdrawal-dos": 2,
      "dos-unbounded-operation": 1,
      "missing-input-validation": 1,
      "erc7821-batch-authorization": 1,
      "test-governance": 1,
      "signature-replay": 1,
      "cross-chain-replay": 1,
      "circular-dependency": 2,
      "eip7702-delegate-access-control": 1,
      "validator-front-running": 1
    },
    "findings": [
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_to' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 30,
          "column": 31,
          "length": 3
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_to != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_receivers' of type 'array' may need validation",
        "severity": "medium",
        "location": {
          "line": 43,
          "column": 45,
          "length": 10
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_receivers.length > 0, \"Array cannot be empty\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_value' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 43,
          "column": 65,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add appropriate range validation for _value",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'transfer' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 30,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'transfer'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "token-supply-manipulation",
        "message": "Function '' has token supply manipulation vulnerability. Function directly modifies totalSupply variable, bypasses mint/burn controls for supply manipulation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation.",
        "severity": "critical",
        "location": {
          "line": 24,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Fix token supply controls in ''. Implement maximum supply cap, add minting rate limits, require multi-signature for minting, add supply change events, validate burn amounts, and implement supply monitoring.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'batchTransfer' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 43,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'batchTransfer'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'transfer' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 30,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'transfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'batchTransfer' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 43,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'batchTransfer' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 43,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'batchTransfer' contains excessive gas usage pattern. Event emission inside loop. Can cause excessive gas costs for large arrays Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 43,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 19,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'transfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 30,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'batchTransfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 43,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'batchTransfer' contains variable shadowing. Local variable 'count' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 43,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'batchTransfer'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'batchTransfer' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 43,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'batchTransfer'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "token-decimal-confusion",
        "message": "Token price/exchange calculation without decimal normalization - incorrect conversions",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5573
        },
        "fix_suggestion": {
          "description": "Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()",
          "replacements": []
        }
      },
      {
        "detector_id": "token-decimal-confusion",
        "message": "Decimal-sensitive math operations without validation - verify decimal assumptions",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5573
        },
        "fix_suggestion": {
          "description": "Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-priority-gas-auction",
        "message": "First-come-first-served mint - creates PGA where users bid up gas to mint first",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5573
        },
        "fix_suggestion": {
          "description": "Use commit-reveal, whitelist, or fair launch mechanism instead of FCFS",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "multisig-bypass",
        "message": "Missing domain separator in signature hash (cross-contract/chain replay)",
        "severity": "medium",
        "location": {
          "line": 0,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Include domain separator: bytes32 domainSeparator = keccak256(abi.encode(TYPEHASH, address(this), block.chainid)); bytes32 hash = keccak256(abi.encodePacked(domainSeparator, data));",
          "replacements": []
        }
      },
      {
        "detector_id": "multisig-bypass",
        "message": "Signatures without expiration/deadline (indefinite validity risk)",
        "severity": "medium",
        "location": {
          "line": 0,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, \"Signature expired\"); Prevents execution of stale signatures.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-storage-collision",
        "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "post-080-overflow",
        "message": "Type casting to smaller uint - verify no overflow on downcast",
        "severity": "low",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Downcasting can silently overflow even in Solidity 0.8.0+!\n\n\u274c UNSAFE DOWNCAST:\nuint256 bigValue = 1000;\nuint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)\n\n\u2705 SAFE DOWNCAST with validation:\nuint256 bigValue = 1000;\nrequire(bigValue <= type(uint8).max, \"Value too large\");\nuint8 smallValue = uint8(bigValue);  // Safe now\n\n\u2705 USE SafeCast library (OpenZeppelin):\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nuint256 bigValue = 1000;\nuint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255\n\nType limits:\n- uint8:   0 to 255\n- uint16:  0 to 65,535\n- uint32:  0 to 4,294,967,295\n- uint64:  0 to 18,446,744,073,709,551,615\n- uint256: 0 to 2^256-1",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5573
        },
        "fix_suggestion": {
          "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5573
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5573
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5573
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'transferBetweenUsers' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 94,
          "column": 14,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'transferBetweenUsers'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_token' in function 'deposit' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 30,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_token != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_token' in function 'withdraw' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 76,
          "column": 31,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_token != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_token' in function 'transferBetweenUsers' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 95,
          "column": 17,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_token != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_from' in function 'transferBetweenUsers' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 96,
          "column": 17,
          "length": 5
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_from != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_to' in function 'transferBetweenUsers' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 97,
          "column": 17,
          "length": 3
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_to != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "array-bounds-check",
        "message": "Function 'batchDeposit' has multiple array parameters but no apparent length validation",
        "severity": "high",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add length validation: require(array1.length == array2.length, \"Array length mismatch\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_token' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 69,
          "column": 30,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_token != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_token' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 76,
          "column": 31,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_token != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Function 'batchDeposit' has multiple array parameters (_tokens, _amounts) but no length consistency validation",
        "severity": "medium",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add validation: require(_tokens.length == _amounts.length, \"Array length mismatch\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Function 'batchDeposit' has related array parameters '_tokens' and '_amounts' that should be validated for equal length",
        "severity": "medium",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add validation: require(_tokens.length == _amounts.length, \"Related arrays must have equal length\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_tokens' of type 'array' may need validation",
        "severity": "medium",
        "location": {
          "line": 84,
          "column": 26,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_tokens.length > 0, \"Array cannot be empty\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amounts' of type 'array' may need validation",
        "severity": "medium",
        "location": {
          "line": 85,
          "column": 26,
          "length": 8
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amounts.length > 0, \"Array cannot be empty\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_token' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 95,
          "column": 17,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_token != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_from' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 96,
          "column": 17,
          "length": 5
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_from != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_to' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 97,
          "column": 17,
          "length": 3
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_to != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdraw' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 76,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'batchDeposit' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'batchDeposit'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'deposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 69,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'deposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'batchDeposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'batchDeposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'batchDeposit' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'batchDeposit'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'batchDeposit' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'batchDeposit'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-input-validation",
        "message": "Function 'batchDeposit' missing input validation. Function with array parameter lacks length validation Missing validation can lead to unexpected behavior, zero address transfers, or invalid state.",
        "severity": "medium",
        "location": {
          "line": 83,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add input validation to 'batchDeposit'. Implement: (1) Zero address checks for address parameters, (2) Bounds validation for numeric inputs, (3) Array length validation, (4) require() statements at function start, (5) OpenZeppelin Address library for address validation.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc7821-batch-authorization",
        "message": "Missing authorization in batch executor 'batchDeposit' - anyone can execute arbitrary calls",
        "severity": "critical",
        "location": {
          "line": 83,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add authorization check:\n\naddress public owner;\n\nfunction executeBatch(\naddress[] calldata targets,\nbytes[] calldata datas\n) external {\nrequire(msg.sender == owner, \"Not authorized\");\n\nfor (uint i = 0; i < targets.length; i++) {\n(bool success,) = targets[i].call(datas[i]);\nrequire(success);\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_target' in function 'execute' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 122,
          "column": 17,
          "length": 7
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_target != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_target' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 122,
          "column": 17,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_target != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Function 'execute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
        "severity": "medium",
        "location": {
          "line": 121,
          "column": 0,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Implement time-delayed voting rights requiring minimum holding periods.",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-replay",
        "message": "Function 'execute' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
        "severity": "high",
        "location": {
          "line": 121,
          "column": 0,
          "length": 7
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
          "replacements": []
        }
      },
      {
        "detector_id": "cross-chain-replay",
        "message": "Function 'execute' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.",
        "severity": "critical",
        "location": {
          "line": 121,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Include 'block.chainid' in the hash calculation for function 'execute'. Example: keccak256(abi.encodePacked(..., block.chainid))",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'execute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 121,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'execute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'execute' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 121,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'claimTokens' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 154,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'claimTokens'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_recipient' in function 'claimTokens' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 154,
          "column": 34,
          "length": 10
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_recipient != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_recipient' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 154,
          "column": 34,
          "length": 10
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_recipient != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 154,
          "column": 54,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'claimTokens' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 154,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'claimTokens' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'claimTokens' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 154,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'claimTokens'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'claimTokens' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 154,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'claimTokens'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'claimTokens' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 154,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'claimTokens'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'claimTokens' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 154,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'claimTokens'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "SignatureReplay",
    "total_findings": 61,
    "critical": 9,
    "high": 27,
    "medium": 13,
    "low": 12,
    "detectors": {
      "missing-access-modifiers": 1,
      "missing-zero-address-check": 5,
      "parameter-consistency": 5,
      "signature-replay": 4,
      "cross-chain-replay": 4,
      "signature-malleability": 4,
      "excessive-gas-usage": 1,
      "inefficient-storage": 5,
      "erc20-transfer-return-bomb": 2,
      "cross-rollup-atomicity": 1,
      "floating-pragma": 1,
      "multisig-bypass": 3,
      "eip7702-storage-collision": 1,
      "logic-error-patterns": 1,
      "enhanced-input-validation": 2,
      "post-080-overflow": 2,
      "jit-liquidity-sandwich": 1,
      "pool-donation-enhanced": 2,
      "invalid-state-transition": 1,
      "unchecked-external-call": 1,
      "vault-withdrawal-dos": 1,
      "vault-hook-reentrancy": 1,
      "mev-extractable-value": 3,
      "gas-griefing": 1,
      "insufficient-randomness": 1,
      "test-governance": 2,
      "circular-dependency": 2,
      "eip7702-delegate-access-control": 2,
      "nonce-reuse": 1
    },
    "findings": [
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'metaTransfer' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 19,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'metaTransfer'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter 'from' in function 'metaTransfer' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 20,
          "column": 17,
          "length": 4
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(from != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter 'to' in function 'metaTransfer' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 21,
          "column": 17,
          "length": 2
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(to != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter 'to' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 21,
          "column": 17,
          "length": 2
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(to != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-replay",
        "message": "Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
        "severity": "high",
        "location": {
          "line": 40,
          "column": 0,
          "length": 13
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
          "replacements": []
        }
      },
      {
        "detector_id": "cross-chain-replay",
        "message": "Function 'metaTransfer' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.",
        "severity": "critical",
        "location": {
          "line": 19,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Include 'block.chainid' in the hash calculation for function 'metaTransfer'. Example: keccak256(abi.encodePacked(..., block.chainid))",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-malleability",
        "message": "Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.",
        "severity": "high",
        "location": {
          "line": 40,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature 's' value\");` This ensures s is in the lower half of the curve order.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'metaTransfer' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 19,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'metaTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 45,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 93,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 141,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 186,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'metaTransfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 19,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 6915
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Low-level call to token without gas limit - return bomb can exhaust all gas",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 6915
        },
        "fix_suggestion": {
          "description": "Specify gas limit for calls: token.call{gas: 100000}(abi.encodeWithSelector(...))",
          "replacements": []
        }
      },
      {
        "detector_id": "cross-rollup-atomicity",
        "message": "Cross-rollup operation lacks atomicity guarantee - partial execution possible",
        "severity": "critical",
        "location": {
          "line": 1,
          "column": 1,
          "length": 6915
        },
        "fix_suggestion": {
          "description": "Implement two-phase commit or rollback mechanism",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "multisig-bypass",
        "message": "Missing signature malleability protection (duplicate signature acceptance)",
        "severity": "high",
        "location": {
          "line": 0,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Check s-value: require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid s-value\"); This prevents signature malleability.",
          "replacements": []
        }
      },
      {
        "detector_id": "multisig-bypass",
        "message": "Missing domain separator in signature hash (cross-contract/chain replay)",
        "severity": "medium",
        "location": {
          "line": 0,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Include domain separator: bytes32 domainSeparator = keccak256(abi.encode(TYPEHASH, address(this), block.chainid)); bytes32 hash = keccak256(abi.encodePacked(domainSeparator, data));",
          "replacements": []
        }
      },
      {
        "detector_id": "multisig-bypass",
        "message": "Signatures without expiration/deadline (indefinite validity risk)",
        "severity": "medium",
        "location": {
          "line": 0,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, \"Signature expired\"); Prevents execution of stale signatures.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-storage-collision",
        "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "post-080-overflow",
        "message": "Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\ud83d\udea8 CRITICAL: Assembly has NO overflow protection!\n\nReal incident: Cetus DEX - $223M loss (May 2025)\nCause: Assembly arithmetic overflow\n\n\u274c VULNERABLE (Cetus-style vulnerability):\nassembly {\nlet result := add(a, b)  // NO OVERFLOW CHECK!\nlet product := mul(x, y) // NO OVERFLOW CHECK!\nmstore(0x00, result)\n}\n\n\u2705 SOLUTION 1 - Add manual checks:\nassembly {\nlet result := add(a, b)\n// Manual overflow check\nif lt(result, a) {\nrevert(0, 0)  // Overflow detected\n}\n}\n\n\u2705 SOLUTION 2 - Use Solidity instead:\n// Let Solidity handle overflow checks\nuint256 result = a + b;  // Automatic overflow check\n\n\u2705 SOLUTION 3 - SafeMath for assembly:\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c;\nassembly {\nc := add(a, b)\n}\nrequire(c >= a, \"Overflow\");  // Check outside assembly\nreturn c;\n}\n\nAssembly arithmetic operations with NO checks:\n- add(a, b)     \u2192 wraps on overflow\n- sub(a, b)     \u2192 wraps on underflow\n- mul(a, b)     \u2192 wraps on overflow\n- div(a, b)     \u2192 returns 0 if b is 0 (no revert!)\n\n\u26a0\ufe0f Only use assembly arithmetic when absolutely necessary\nand with manual overflow checks!",
          "replacements": []
        }
      },
      {
        "detector_id": "post-080-overflow",
        "message": "Type casting to smaller uint - verify no overflow on downcast",
        "severity": "low",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Downcasting can silently overflow even in Solidity 0.8.0+!\n\n\u274c UNSAFE DOWNCAST:\nuint256 bigValue = 1000;\nuint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)\n\n\u2705 SAFE DOWNCAST with validation:\nuint256 bigValue = 1000;\nrequire(bigValue <= type(uint8).max, \"Value too large\");\nuint8 smallValue = uint8(bigValue);  // Safe now\n\n\u2705 USE SafeCast library (OpenZeppelin):\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nuint256 bigValue = 1000;\nuint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255\n\nType limits:\n- uint8:   0 to 255\n- uint16:  0 to 65,535\n- uint32:  0 to 4,294,967,295\n- uint64:  0 to 18,446,744,073,709,551,615\n- uint256: 0 to 2^256-1",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 6915
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 6915
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 6915
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 81,
          "column": 9,
          "length": 36
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter 'amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 69,
          "column": 17,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'redeemVoucher' does not check return value",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'redeemVoucher'",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-replay",
        "message": "Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
        "severity": "high",
        "location": {
          "line": 88,
          "column": 0,
          "length": 13
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
          "replacements": []
        }
      },
      {
        "detector_id": "cross-chain-replay",
        "message": "Function 'redeemVoucher' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.",
        "severity": "critical",
        "location": {
          "line": 68,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Include 'block.chainid' in the hash calculation for function 'redeemVoucher'. Example: keccak256(abi.encodePacked(..., block.chainid))",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-malleability",
        "message": "Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.",
        "severity": "high",
        "location": {
          "line": 88,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature 's' value\");` This ensures s is in the lower half of the curve order.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'redeemVoucher' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'redeemVoucher' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-hook-reentrancy",
        "message": "Function 'redeemVoucher' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'redeemVoucher' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'redeemVoucher' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'redeemVoucher'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'redeemVoucher' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'redeemVoucher'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "insufficient-randomness",
        "message": "Function 'redeemVoucher' uses weak randomness source. Uses user address in randomness without commitment scheme. Users can predict outcomes and selectively participate Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-338",
        "fix_suggestion": {
          "description": "Use secure randomness in 'redeemVoucher'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter 'target' in function 'executeWithSignature' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 114,
          "column": 17,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(target != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter 'value' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 115,
          "column": 17,
          "length": 5
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add appropriate range validation for value",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Function 'executeWithSignature' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
        "severity": "medium",
        "location": {
          "line": 113,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Implement time-delayed voting rights requiring minimum holding periods.",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-replay",
        "message": "Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
        "severity": "high",
        "location": {
          "line": 136,
          "column": 0,
          "length": 13
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
          "replacements": []
        }
      },
      {
        "detector_id": "cross-chain-replay",
        "message": "Function 'executeWithSignature' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.",
        "severity": "critical",
        "location": {
          "line": 113,
          "column": 14,
          "length": 20
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Include 'block.chainid' in the hash calculation for function 'executeWithSignature'. Example: keccak256(abi.encodePacked(..., block.chainid))",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-malleability",
        "message": "Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.",
        "severity": "high",
        "location": {
          "line": 136,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature 's' value\");` This ensures s is in the lower half of the curve order.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'executeWithSignature' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 113,
          "column": 14,
          "length": 20
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'executeWithSignature'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'executeWithSignature' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 113,
          "column": 14,
          "length": 20
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'executeWithSignature'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'executeWithSignature' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 113,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter 'user' in function 'executeMetaTransaction' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 162,
          "column": 17,
          "length": 4
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(user != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter 'target' in function 'executeMetaTransaction' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 163,
          "column": 17,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(target != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter 'target' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 163,
          "column": 17,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(target != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter 'value' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 164,
          "column": 17,
          "length": 5
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add appropriate range validation for value",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Function 'executeMetaTransaction' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
        "severity": "medium",
        "location": {
          "line": 161,
          "column": 0,
          "length": 22
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Implement time-delayed voting rights requiring minimum holding periods.",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-replay",
        "message": "Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
        "severity": "high",
        "location": {
          "line": 181,
          "column": 0,
          "length": 13
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
          "replacements": []
        }
      },
      {
        "detector_id": "cross-chain-replay",
        "message": "Function 'executeMetaTransaction' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.",
        "severity": "critical",
        "location": {
          "line": 161,
          "column": 14,
          "length": 22
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Include 'block.chainid' in the hash calculation for function 'executeMetaTransaction'. Example: keccak256(abi.encodePacked(..., block.chainid))",
          "replacements": []
        }
      },
      {
        "detector_id": "signature-malleability",
        "message": "Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.",
        "severity": "high",
        "location": {
          "line": 181,
          "column": 14,
          "length": 13
        },
        "cwe": "CWE-347",
        "fix_suggestion": {
          "description": "Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature 's' value\");` This ensures s is in the lower half of the curve order.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'executeMetaTransaction' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 161,
          "column": 14,
          "length": 22
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'executeMetaTransaction'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "nonce-reuse",
        "message": "Function 'executeMetaTransaction' has nonce management vulnerability. Uses global nonce instead of per-user mapping, forces sequential execution and limits parallelization Improper nonce handling enables replay attacks or transaction reordering exploits.",
        "severity": "medium",
        "location": {
          "line": 161,
          "column": 14,
          "length": 22
        },
        "cwe": "CWE-294",
        "fix_suggestion": {
          "description": "Fix nonce management in 'executeMetaTransaction'. Increment nonce after validation, use mapping(address => uint256) for per-user nonces, validate nonce before execution, include nonce in signature hash, and implement nonce cancellation mechanism.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'executeMetaTransaction' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 161,
          "column": 14,
          "length": 22
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'executeMetaTransaction'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'executeMetaTransaction' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 161,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "TimestampDependence",
    "total_findings": 72,
    "critical": 11,
    "high": 32,
    "medium": 24,
    "low": 5,
    "detectors": {
      "classic-reentrancy": 2,
      "invalid-state-transition": 3,
      "array-bounds-check": 1,
      "single-oracle-source": 1,
      "unchecked-external-call": 4,
      "timestamp-manipulation": 7,
      "mev-extractable-value": 3,
      "gas-griefing": 5,
      "dos-unbounded-operation": 1,
      "inefficient-storage": 1,
      "front-running-mitigation": 1,
      "centralization-risk": 2,
      "insufficient-randomness": 4,
      "shadowing-variables": 5,
      "deprecated-functions": 1,
      "unsafe-type-casting": 4,
      "time-locked-admin-bypass": 2,
      "guardian-role-centralization": 1,
      "erc20-transfer-return-bomb": 1,
      "floating-pragma": 1,
      "transient-storage-reentrancy": 6,
      "logic-error-patterns": 2,
      "oracle-time-window-attack": 1,
      "enhanced-input-validation": 2,
      "jit-liquidity-sandwich": 1,
      "pool-donation-enhanced": 2,
      "vault-withdrawal-dos": 2,
      "vault-hook-reentrancy": 2,
      "withdrawal-delay": 2,
      "excessive-gas-usage": 2
    },
    "findings": [
      {
        "detector_id": "classic-reentrancy",
        "message": "Function 'drawWinner' may be vulnerable to reentrancy attacks due to state changes after external calls",
        "severity": "high",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Apply checks-effects-interactions pattern or use a reentrancy guard in function 'drawWinner'",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 37,
          "column": 9,
          "length": 47
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "array-bounds-check",
        "message": "Array access to 'players' may be out of bounds - index not validated",
        "severity": "high",
        "location": {
          "line": 35,
          "column": 26,
          "length": 20
        },
        "cwe": "CWE-125",
        "fix_suggestion": {
          "description": "Add bounds check: require(index < players.length, \"Index out of bounds\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'buyTicket' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 22,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'buyTicket'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'buyTicket' does not check return value",
        "severity": "medium",
        "location": {
          "line": 22,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'buyTicket'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'drawWinner' does not check return value",
        "severity": "medium",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'drawWinner'",
          "replacements": []
        }
      },
      {
        "detector_id": "timestamp-manipulation",
        "message": "Function '' has dangerous timestamp dependency. Uses block.timestamp for randomness or lottery selection, allowing miners to manipulate outcomes by choosing favorable timestamps Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
        "severity": "high",
        "location": {
          "line": 17,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-367",
        "fix_suggestion": {
          "description": "Reduce timestamp dependency in ''. Use block.number for time intervals, add tolerance ranges (\u00b115 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
          "replacements": []
        }
      },
      {
        "detector_id": "timestamp-manipulation",
        "message": "Function 'buyTicket' has dangerous timestamp dependency. Uses block.timestamp for randomness or lottery selection, allowing miners to manipulate outcomes by choosing favorable timestamps Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
        "severity": "high",
        "location": {
          "line": 22,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-367",
        "fix_suggestion": {
          "description": "Reduce timestamp dependency in 'buyTicket'. Use block.number for time intervals, add tolerance ranges (\u00b115 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
          "replacements": []
        }
      },
      {
        "detector_id": "timestamp-manipulation",
        "message": "Function 'drawWinner' has dangerous timestamp dependency. Uses block.timestamp for randomness or lottery selection, allowing miners to manipulate outcomes by choosing favorable timestamps Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
        "severity": "high",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-367",
        "fix_suggestion": {
          "description": "Reduce timestamp dependency in 'drawWinner'. Use block.number for time intervals, add tolerance ranges (\u00b115 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'drawWinner' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'drawWinner'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'drawWinner' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'drawWinner'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'drawWinner' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'drawWinner'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'withdraw' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 58,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "front-running-mitigation",
        "message": "Function 'buyTicket' lacks front-running protection. Trading function 'buyTicket' missing slippage protection (minAmountOut). Vulnerable to sandwich attacks Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
        "severity": "high",
        "location": {
          "line": 22,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add front-running protection to 'buyTicket'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "insufficient-randomness",
        "message": "Function '' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
        "severity": "high",
        "location": {
          "line": 17,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-338",
        "fix_suggestion": {
          "description": "Use secure randomness in ''. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
          "replacements": []
        }
      },
      {
        "detector_id": "insufficient-randomness",
        "message": "Function 'buyTicket' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
        "severity": "high",
        "location": {
          "line": 22,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-338",
        "fix_suggestion": {
          "description": "Use secure randomness in 'buyTicket'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
          "replacements": []
        }
      },
      {
        "detector_id": "insufficient-randomness",
        "message": "Function 'drawWinner' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
        "severity": "high",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-338",
        "fix_suggestion": {
          "description": "Use secure randomness in 'drawWinner'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'buyTicket' contains variable shadowing. Parameter 'lotteryEndTime' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 22,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'buyTicket'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'buyTicket' contains variable shadowing. Parameter 'ticketPrice' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 22,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'buyTicket'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'drawWinner' contains variable shadowing. Parameter 'lotteryEndTime' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'drawWinner'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'drawWinner' contains variable shadowing. Local variable 'winner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 29,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'drawWinner'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "deprecated-functions",
        "message": "Deprecated function or pattern detected: 'block.difficulty'. block.difficulty deprecated post-merge. Use block.prevrandao instead",
        "severity": "low",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-477",
        "fix_suggestion": {
          "description": "Replace deprecated 'block.difficulty'. block.difficulty deprecated post-merge. Use block.prevrandao instead",
          "replacements": []
        }
      },
      {
        "detector_id": "unsafe-type-casting",
        "message": "Function 'drawWinner' contains unsafe type casting. int to uint conversion without sign check. Negative values will wrap to large positive Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
        "severity": "medium",
        "location": {
          "line": 33,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-704",
        "fix_suggestion": {
          "description": "Add safe type casting in 'drawWinner'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
          "replacements": []
        }
      },
      {
        "detector_id": "unsafe-type-casting",
        "message": "Function 'drawWinner' contains unsafe type casting. uint to int conversion without overflow check. Large values may become negative Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
        "severity": "medium",
        "location": {
          "line": 33,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-704",
        "fix_suggestion": {
          "description": "Add safe type casting in 'drawWinner'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
          "replacements": []
        }
      },
      {
        "detector_id": "time-locked-admin-bypass",
        "message": "Timelock implementation incomplete - missing queue/schedule or execute functions",
        "severity": "critical",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3628
        },
        "fix_suggestion": {
          "description": "Implement complete timelock flow: propose\u2192queue\u2192wait(delay)\u2192execute",
          "replacements": []
        }
      },
      {
        "detector_id": "time-locked-admin-bypass",
        "message": "Emergency functions bypass timelock without multisig protection",
        "severity": "critical",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3628
        },
        "fix_suggestion": {
          "description": "Require multisig approval for emergency functions that bypass timelock",
          "replacements": []
        }
      },
      {
        "detector_id": "guardian-role-centralization",
        "message": "Guardian role lacks explicit revocation mechanism - may be irremovable if compromised",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3628
        },
        "fix_suggestion": {
          "description": "Implement guardian revocation function callable by DAO/owner for emergency scenarios",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3628
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'drawWinner' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 29,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Classic reentrancy pattern with transient storage risk in 'drawWinner'",
        "severity": "critical",
        "location": {
          "line": 29,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() \u2190 attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 \u2190 do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Percentage calculation - verify order of operations for precision",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Percentage calculations require careful ordering:\n\n\u274c WRONG (precision loss):\nuint256 fee = (amount / 10000) * feePercent;\n\n\u2705 CORRECT:\nuint256 fee = (amount * feePercent) / 10000;\n\n\u2705 BEST (with basis points):\nuint256 constant BASIS_POINTS = 10000;\nuint256 fee = (amount * feeBasisPoints) / BASIS_POINTS;\n\nExample: 250 basis points = 2.5%\namount = 1000, feeBasisPoints = 250\nfee = (1000 * 250) / 10000 = 25 \u2705\n\nWRONG order:\nfee = (1000 / 10000) * 250 = 0 * 250 = 0 \u274c",
          "replacements": []
        }
      },
      {
        "detector_id": "oracle-time-window-attack",
        "message": "Oracle price usage without time-weighted average - consider TWAP",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Single-block price oracles are manipulable:\n\n\u274c Vulnerable patterns:\n- Using spot price from DEX\n- Single block price snapshot\n- No time-weighting\n- No price deviation checks\n\n\u2705 Recommended solutions:\n\n1. Use Uniswap V3 TWAP (30+ minute window)\n2. Use Chainlink Price Feeds (aggregated off-chain)\n3. Combine multiple oracle sources\n4. Implement price deviation bounds:\nrequire(abs(newPrice - lastPrice) < maxDelta);\n5. Use time-weighted moving average:\npriceSum += currentPrice;\npriceCount++;\navgPrice = priceSum / priceCount;\n\nMinimum TWAP window: 30 minutes (longer is better)\nMaximum price deviation: 2-5% from last update",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3628
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3628
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3628
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "classic-reentrancy",
        "message": "Function 'emergencyWithdraw' may be vulnerable to reentrancy attacks due to state changes after external calls",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Apply checks-effects-interactions pattern or use a reentrancy guard in function 'emergencyWithdraw'",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 65,
          "column": 9,
          "length": 36
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 72,
          "column": 9,
          "length": 50
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'withdraw' does not check return value",
        "severity": "medium",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'withdraw'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'emergencyWithdraw' does not check return value",
        "severity": "medium",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'emergencyWithdraw'",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'emergencyWithdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'emergencyWithdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-hook-reentrancy",
        "message": "Function 'withdraw' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
        "severity": "high",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'withdraw' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-hook-reentrancy",
        "message": "Function 'emergencyWithdraw' may be vulnerable to hook reentrancy attack. State changes after token transfer without reentrancy guard. ERC-777/ERC-1363 callbacks can re-enter before state updates complete ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'emergencyWithdraw' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "timestamp-manipulation",
        "message": "Function 'deposit' has dangerous timestamp dependency. Performs arithmetic on block.timestamp without overflow protection, potentially manipulable by miners within bounds Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
        "severity": "high",
        "location": {
          "line": 51,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-367",
        "fix_suggestion": {
          "description": "Reduce timestamp dependency in 'deposit'. Use block.number for time intervals, add tolerance ranges (\u00b115 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
          "replacements": []
        }
      },
      {
        "detector_id": "timestamp-manipulation",
        "message": "Function 'withdraw' has dangerous timestamp dependency. Critical operations (transfer/mint/burn/withdraw) controlled by timestamp, enabling miners to manipulate timing for advantage Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
        "severity": "high",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-367",
        "fix_suggestion": {
          "description": "Reduce timestamp dependency in 'withdraw'. Use block.number for time intervals, add tolerance ranges (\u00b115 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
          "replacements": []
        }
      },
      {
        "detector_id": "timestamp-manipulation",
        "message": "Function 'emergencyWithdraw' has dangerous timestamp dependency. Critical operations (transfer/mint/burn/withdraw) controlled by timestamp, enabling miners to manipulate timing for advantage Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-367",
        "fix_suggestion": {
          "description": "Reduce timestamp dependency in 'emergencyWithdraw'. Use block.number for time intervals, add tolerance ranges (\u00b115 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
          "replacements": []
        }
      },
      {
        "detector_id": "withdrawal-delay",
        "message": "Function 'withdraw' has withdrawal delay vulnerability. Withdrawal delay has no maximum cap, admin can set arbitrarily long delays locking funds indefinitely Improper withdrawal mechanisms can lock user funds indefinitely or enable denial of service.",
        "severity": "high",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Fix withdrawal mechanism in 'withdraw'. Implement maximum withdrawal delay caps, add emergency withdrawal options with penalties, prevent admin from extending delays arbitrarily, implement fair queue systems, add partial withdrawal capabilities, and document clear withdrawal timelines.",
          "replacements": []
        }
      },
      {
        "detector_id": "withdrawal-delay",
        "message": "Function 'emergencyWithdraw' has withdrawal delay vulnerability. Withdrawal delay has no maximum cap, admin can set arbitrarily long delays locking funds indefinitely Improper withdrawal mechanisms can lock user funds indefinitely or enable denial of service.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Fix withdrawal mechanism in 'emergencyWithdraw'. Implement maximum withdrawal delay caps, add emergency withdrawal options with penalties, prevent admin from extending delays arbitrarily, implement fair queue systems, add partial withdrawal capabilities, and document clear withdrawal timelines.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'deposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 51,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'deposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'withdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'withdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'emergencyWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'emergencyWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'withdraw' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'withdraw'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'emergencyWithdraw' contains excessive gas usage pattern. Multiple storage reads detected (4). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'emergencyWithdraw'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Function 'emergencyWithdraw' has centralization risk. Emergency function 'emergencyWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.",
        "severity": "high",
        "location": {
          "line": 69,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Add decentralization to 'emergencyWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'withdraw' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 58,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'withdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'withdraw' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 58,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'emergencyWithdraw' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 69,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Classic reentrancy pattern with transient storage risk in 'emergencyWithdraw'",
        "severity": "critical",
        "location": {
          "line": 69,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() \u2190 attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 \u2190 do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
          "replacements": []
        }
      },
      {
        "detector_id": "timestamp-manipulation",
        "message": "Function 'generateRandomNumber' has dangerous timestamp dependency. Uses block.timestamp for randomness or lottery selection, allowing miners to manipulate outcomes by choosing favorable timestamps Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
        "severity": "high",
        "location": {
          "line": 85,
          "column": 14,
          "length": 20
        },
        "cwe": "CWE-367",
        "fix_suggestion": {
          "description": "Reduce timestamp dependency in 'generateRandomNumber'. Use block.number for time intervals, add tolerance ranges (\u00b115 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'generateRandomNumber' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 85,
          "column": 14,
          "length": 20
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'generateRandomNumber'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'playGame' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 98,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'playGame'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'playGame' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 98,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'playGame'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "insufficient-randomness",
        "message": "Function 'generateRandomNumber' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
        "severity": "high",
        "location": {
          "line": 85,
          "column": 14,
          "length": 20
        },
        "cwe": "CWE-338",
        "fix_suggestion": {
          "description": "Use secure randomness in 'generateRandomNumber'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
          "replacements": []
        }
      },
      {
        "detector_id": "unsafe-type-casting",
        "message": "Function 'generateRandomNumber' contains unsafe type casting. int to uint conversion without sign check. Negative values will wrap to large positive Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
        "severity": "medium",
        "location": {
          "line": 86,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-704",
        "fix_suggestion": {
          "description": "Add safe type casting in 'generateRandomNumber'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
          "replacements": []
        }
      },
      {
        "detector_id": "unsafe-type-casting",
        "message": "Function 'generateRandomNumber' contains unsafe type casting. uint to int conversion without overflow check. Large values may become negative Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
        "severity": "medium",
        "location": {
          "line": 86,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-704",
        "fix_suggestion": {
          "description": "Add safe type casting in 'generateRandomNumber'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'playGame' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 98,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "UncheckedCall",
    "total_findings": 78,
    "critical": 11,
    "high": 32,
    "medium": 23,
    "low": 12,
    "detectors": {
      "invalid-state-transition": 2,
      "array-bounds-check": 1,
      "parameter-consistency": 5,
      "single-oracle-source": 3,
      "unchecked-external-call": 3,
      "external-calls-loop": 1,
      "vault-withdrawal-dos": 3,
      "mev-extractable-value": 3,
      "circular-dependency": 1,
      "gas-griefing": 2,
      "excessive-gas-usage": 3,
      "inefficient-storage": 2,
      "centralization-risk": 1,
      "deprecated-functions": 1,
      "erc20-transfer-return-bomb": 2,
      "defi-yield-farming-exploits": 14,
      "erc777-reentrancy-hooks": 1,
      "floating-pragma": 1,
      "transient-storage-reentrancy": 2,
      "eip7702-delegate-access-control": 1,
      "eip7702-storage-collision": 1,
      "eip7702-batch-phishing": 1,
      "erc7821-batch-authorization": 1,
      "erc7821-replay-protection": 1,
      "logic-error-patterns": 2,
      "enhanced-input-validation": 2,
      "post-080-overflow": 1,
      "jit-liquidity-sandwich": 2,
      "yield-farming-manipulation": 1,
      "pool-donation-enhanced": 2,
      "missing-access-modifiers": 2,
      "classic-reentrancy": 1,
      "missing-zero-address-check": 2,
      "vault-hook-reentrancy": 1,
      "validator-front-running": 3,
      "shadowing-variables": 2,
      "unchecked-math": 1
    },
    "findings": [
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 33,
          "column": 9,
          "length": 24
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "array-bounds-check",
        "message": "Function 'batchPayout' has multiple array parameters but no apparent length validation",
        "severity": "high",
        "location": {
          "line": 37,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add length validation: require(array1.length == array2.length, \"Array length mismatch\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Function 'batchPayout' has related array parameters '_recipients' and '_amounts' that should be validated for equal length",
        "severity": "medium",
        "location": {
          "line": 37,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add validation: require(_recipients.length == _amounts.length, \"Related arrays must have equal length\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'withdrawWithSend' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 28,
          "column": 14,
          "length": 16
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'withdrawWithSend'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'withdrawWithSend' does not check return value",
        "severity": "medium",
        "location": {
          "line": 28,
          "column": 14,
          "length": 16
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'withdrawWithSend'",
          "replacements": []
        }
      },
      {
        "detector_id": "external-calls-loop",
        "message": "Function 'batchPayout' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.",
        "severity": "high",
        "location": {
          "line": 37,
          "column": 0,
          "length": 11
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdrawUnchecked' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 18,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdrawUnchecked' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdrawWithSend' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 28,
          "column": 14,
          "length": 16
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdrawWithSend' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'batchPayout' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 37,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'batchPayout'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'batchPayout' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 37,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'batchPayout'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'batchPayout' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 37,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'batchPayout'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'withdrawUnchecked' contains excessive gas usage pattern. Multiple storage reads detected (6). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 18,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'withdrawUnchecked'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'withdrawWithSend' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 28,
          "column": 14,
          "length": 16
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'withdrawWithSend'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'batchPayout' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 37,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'batchPayout'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'withdrawUnchecked' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 18,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'withdrawWithSend' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 28,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "deprecated-functions",
        "message": "Deprecated function or pattern detected: '.send'. Use .call{value: amount}(\"\") instead of .send() for better error handling",
        "severity": "low",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-477",
        "fix_suggestion": {
          "description": "Replace deprecated '.send'. Use .call{value: amount}(\"\") instead of .send() for better error handling",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3355
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Low-level call to token without gas limit - return bomb can exhaust all gas",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3355
        },
        "fix_suggestion": {
          "description": "Specify gas limit for calls: token.call{gas: 100000}(abi.encodeWithSelector(...))",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No first depositor protection (inflation attack on vault initialization) in 'deposit'",
        "severity": "critical",
        "location": {
          "line": 13,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Lock initial shares: if (totalSupply() == 0) { _mint(address(0), INITIAL_SHARES); }",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No deposit cap (unlimited exposure risk) in 'deposit'",
        "severity": "low",
        "location": {
          "line": 13,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add cap: require(totalAssets() + amount <= depositCap, \"Cap exceeded\");",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No withdrawal fee accounting (fee bypass risk) in 'withdrawUnchecked'",
        "severity": "medium",
        "location": {
          "line": 18,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Asset calculation missing totalSupply/totalAssets in 'withdrawUnchecked'",
        "severity": "high",
        "location": {
          "line": 18,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No withdrawal fee accounting (fee bypass risk) in 'withdrawWithSend'",
        "severity": "medium",
        "location": {
          "line": 28,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Asset calculation missing totalSupply/totalAssets in 'withdrawWithSend'",
        "severity": "high",
        "location": {
          "line": 28,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
          "replacements": []
        }
      },
      {
        "detector_id": "erc777-reentrancy-hooks",
        "message": "Function 'withdrawWithSend' is vulnerable to ERC-777 hook reentrancy. Interacts with ERC-777 tokens without reentrancy guard Historical losses: $18.8M+ (Cream Finance), $25M (LendfMe), $300k (Uniswap V1).",
        "severity": "high",
        "location": {
          "line": 28,
          "column": 14,
          "length": 16
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'withdrawWithSend' from ERC-777 reentrancy. Solutions: (1) Add nonReentrant modifier, (2) Follow checks-effects-interactions pattern, (3) Update state before token transfers, (4) Use pull-over-push pattern",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'batchPayout' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 37,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'batchPayout' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 37,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-storage-collision",
        "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-batch-phishing",
        "message": "Unprotected batch execution in 'batchPayout' - phishing risk",
        "severity": "high",
        "location": {
          "line": 37,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Batch functions without authorization enable phishing:\n\nAttack pattern:\n1. Phishing site prompts EIP-7702 delegation\n2. Malicious batch function executes multiple calls\n3. Drains ETH, all ERC-20s, all NFTs in single transaction\n4. User sees only one transaction signature\n\nFix: Add proper authorization:\nfunction batchExecute(Call[] calldata calls) external {\nrequire(msg.sender == owner, \"Not authorized\");\n\nfor (uint i = 0; i < calls.length; i++) {\n(bool success,) = calls[i].target.call(calls[i].data);\nrequire(success, \"Call failed\");\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "erc7821-batch-authorization",
        "message": "Missing authorization in batch executor 'batchPayout' - anyone can execute arbitrary calls",
        "severity": "critical",
        "location": {
          "line": 37,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add authorization check:\n\naddress public owner;\n\nfunction executeBatch(\naddress[] calldata targets,\nbytes[] calldata datas\n) external {\nrequire(msg.sender == owner, \"Not authorized\");\n\nfor (uint i = 0; i < targets.length; i++) {\n(bool success,) = targets[i].call(datas[i]);\nrequire(success);\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "erc7821-replay-protection",
        "message": "ERC-7821 executor missing replay protection - orders can be executed multiple times",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add nonce-based replay protection:\n\nmapping(address => uint256) public nonces;\n\nfunction executeBatch(\nuint256 nonce,\nbytes calldata signature\n) external {\nrequire(nonce == nonces[msg.sender], \"Invalid nonce\");\nnonces[msg.sender]++;\n\n// Execute batch...\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Reward distribution logic detected - verify precision and rounding",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Common reward distribution errors:\n\n1. Integer division truncation:\n\u274c reward = balance / users;  // Loses remainder\n\u2705 reward = balance * 1e18 / users / 1e18;\n\n2. Accumulating rounding errors:\n\u274c Track individual rewards that sum != total\n\u2705 Use lastUser = total - sum(others)\n\n3. Division before multiplication:\n\u274c (balance / total) * multiplier\n\u2705 (balance * multiplier) / total\n\n4. Missing remainder handling:\nuint256 perUser = total / userCount;\nuint256 remainder = total % userCount;\n// Handle remainder explicitly!",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "post-080-overflow",
        "message": "Unchecked block found - overflows/underflows won't revert (OWASP 2025)",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u26a0\ufe0f UNCHECKED BLOCKS BYPASS SOLIDITY 0.8.0+ PROTECTION!\n\nSolidity 0.8.0+ has automatic overflow/underflow checks,\nbut 'unchecked' blocks disable this protection.\n\n\u274c DANGEROUS if user input involved:\nunchecked {\nbalance += amount;  // Can overflow!\ntotal = a * b;      // Can overflow!\n}\n\n\u2705 SAFE usage (loop counters only):\nfor (uint256 i = 0; i < items.length;) {\n// Process items[i]\n\nunchecked {\n++i;  // Safe: loop counter can't realistically overflow\n}\n}\n\n\u2705 SAFE usage (guaranteed no overflow):\nunchecked {\n// Safe: subtraction after comparison\nif (a >= b) {\nresult = a - b;  // No underflow possible\n}\n}\n\n\u274c NEVER use unchecked for:\n- User-supplied values\n- Token amounts\n- Financial calculations\n- Multiplication of arbitrary values\n\nOnly use unchecked when:\n1. Loop counters (i++, ++i)\n2. Mathematically proven safe\n3. Gas optimization with careful review",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3355
        },
        "fix_suggestion": {
          "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3355
        },
        "fix_suggestion": {
          "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "yield-farming-manipulation",
        "message": "No minimum staking duration enforced - allows instant reward farming",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3355
        },
        "fix_suggestion": {
          "description": "Add minimum staking duration requirement before allowing reward claims",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "No minimum deposit requirement - small deposits may round down to zero shares",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3355
        },
        "fix_suggestion": {
          "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3355
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'claimReward' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'setReward' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 76,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'setReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "classic-reentrancy",
        "message": "Function 'claimReward' may be vulnerable to reentrancy attacks due to state changes after external calls",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Apply checks-effects-interactions pattern or use a reentrancy guard in function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 73,
          "column": 9,
          "length": 36
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_user' in function 'setReward' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 76,
          "column": 32,
          "length": 5
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_user != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_user' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 76,
          "column": 32,
          "length": 5
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_user != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 76,
          "column": 47,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'claimReward' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'claimReward' does not check return value",
        "severity": "medium",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'claimReward' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'claimReward' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-hook-reentrancy",
        "message": "Function 'claimReward' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'claimReward' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'claimReward' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'claimReward'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'setReward' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 76,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'setReward'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'claimReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'claimReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'setReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 76,
          "column": 14,
          "length": 9
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'setReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'claimReward' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'claimReward'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'claimReward' contains variable shadowing. Parameter 'reward' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'claimReward'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'claimReward' contains variable shadowing. Local variable 'reward' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 64,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'claimReward'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation doesn't account for totalSupply in 'claimReward'",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate rewards: rewardPerToken = (rewardRate * timeDelta * 1e18) / totalSupply;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No timestamp tracking for reward accrual in 'claimReward'",
        "severity": "high",
        "location": {
          "line": 64,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Missing reward debt tracking (double-claim risk) in 'claimReward'",
        "severity": "critical",
        "location": {
          "line": 64,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation without precision multiplier (rounding errors) in 'claimReward'",
        "severity": "medium",
        "location": {
          "line": 64,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation doesn't account for totalSupply in 'setReward'",
        "severity": "high",
        "location": {
          "line": 76,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate rewards: rewardPerToken = (rewardRate * timeDelta * 1e18) / totalSupply;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No timestamp tracking for reward accrual in 'setReward'",
        "severity": "high",
        "location": {
          "line": 76,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Missing reward debt tracking (double-claim risk) in 'setReward'",
        "severity": "critical",
        "location": {
          "line": 76,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation without precision multiplier (rounding errors) in 'setReward'",
        "severity": "medium",
        "location": {
          "line": 76,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Vulnerable to transient storage reentrancy in 'claimReward' - transfer()/send() no longer safe with EIP-1153",
        "severity": "critical",
        "location": {
          "line": 64,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// \u2705 Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_vulnerableContract' in function 'attack' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 94,
          "column": 29,
          "length": 19
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_vulnerableContract != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_vulnerableContract' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 94,
          "column": 29,
          "length": 19
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_vulnerableContract != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 94,
          "column": 58,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'attack' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 94,
          "column": 14,
          "length": 6
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'attack'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'attack' does not check return value",
        "severity": "medium",
        "location": {
          "line": 94,
          "column": 14,
          "length": 6
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'attack'",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'attack' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 94,
          "column": 14,
          "length": 6
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'attack'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-math",
        "message": "Function 'attack' contains unchecked arithmetic operations. Unchecked subtraction detected. Subtraction can underflow without reversion Unchecked math can silently overflow/underflow leading to incorrect calculations and potential exploits.",
        "severity": "medium",
        "location": {
          "line": 94,
          "column": 14,
          "length": 6
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Remove unsafe unchecked blocks in 'attack'. Solidity 0.8+ has built-in overflow protection. Only use 'unchecked' for gas optimization when overflow is mathematically impossible. Add explicit validation or use OpenZeppelin SafeMath for Solidity <0.8.",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "UninitializedStorage",
    "total_findings": 58,
    "critical": 12,
    "high": 23,
    "medium": 10,
    "low": 13,
    "detectors": {
      "missing-access-modifiers": 11,
      "missing-zero-address-check": 5,
      "array-bounds-check": 2,
      "parameter-consistency": 10,
      "single-oracle-source": 4,
      "unchecked-external-call": 4,
      "token-supply-manipulation": 1,
      "inefficient-storage": 2,
      "centralization-risk": 1,
      "shadowing-variables": 1,
      "floating-pragma": 1,
      "private-variable-exposure": 1,
      "logic-error-patterns": 1,
      "enhanced-input-validation": 2,
      "pool-donation-enhanced": 1,
      "integer-overflow": 1,
      "dos-unbounded-operation": 4,
      "excessive-gas-usage": 2,
      "mev-extractable-value": 3,
      "erc20-approve-race": 1
    },
    "findings": [
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'addUser' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 33,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'addUser'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'updateUser' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 44,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'updateUser'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_addr' in function 'addUser' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 33,
          "column": 30,
          "length": 5
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_addr != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_addr' in function 'updateUser' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 44,
          "column": 49,
          "length": 5
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_addr != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "array-bounds-check",
        "message": "Array access to 'users' may be out of bounds - index not validated",
        "severity": "high",
        "location": {
          "line": 46,
          "column": 29,
          "length": 13
        },
        "cwe": "CWE-125",
        "fix_suggestion": {
          "description": "Add bounds check: require(index < users.length, \"Index out of bounds\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_addr' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 33,
          "column": 30,
          "length": 5
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_addr != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_addr' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 44,
          "column": 49,
          "length": 5
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_addr != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'addUser' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 33,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'addUser'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'addUser' does not check return value",
        "severity": "medium",
        "location": {
          "line": 33,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'addUser'",
          "replacements": []
        }
      },
      {
        "detector_id": "token-supply-manipulation",
        "message": "Function '' has token supply manipulation vulnerability. Function directly modifies totalSupply variable, bypasses mint/burn controls for supply manipulation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation.",
        "severity": "critical",
        "location": {
          "line": 27,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-682",
        "fix_suggestion": {
          "description": "Fix token supply controls in ''. Implement maximum supply cap, add minting rate limits, require multi-signature for minting, add supply change events, validate burn amounts, and implement supply monitoring.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Struct contains mixed uint256 and smaller types. Pack smaller types together for gas savings Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 19,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'addUser' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 33,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'addUser' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 33,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'addUser'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.7.6;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.7.6;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "private-variable-exposure",
        "message": "Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable",
        "severity": "high",
        "location": {
          "line": 108,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "CRITICAL: 'private' visibility does NOT encrypt data!\n\nAll blockchain storage is publicly readable via:\n- eth_getStorageAt RPC call\n- Block explorers\n- Archive nodes\n\n\u274c This is INSECURE:\nstring private password = \"mysecret123\";\n\n\u2705 Correct approaches:\n\n1. NEVER store secrets on-chain\n2. Store hashes instead:\nbytes32 public passwordHash = keccak256(\"password\");\n\n3. Use commit-reveal for sensitive values:\nbytes32 public commitment = keccak256(abi.encode(value, salt));\n\n4. For truly private data, use off-chain storage or ZK proofs",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "pool-donation-enhanced",
        "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 5827
        },
        "fix_suggestion": {
          "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'addItem' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 81,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'addItem'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_owner' in function 'addItem' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 81,
          "column": 30,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_owner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "array-bounds-check",
        "message": "Array access to 'items' may be out of bounds - index not validated",
        "severity": "high",
        "location": {
          "line": 75,
          "column": 33,
          "length": 8
        },
        "cwe": "CWE-125",
        "fix_suggestion": {
          "description": "Add bounds check: require(index < items.length, \"Index out of bounds\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_owner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 81,
          "column": 30,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_owner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 81,
          "column": 46,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'addItem' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 81,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'addItem'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'addItem' does not check return value",
        "severity": "medium",
        "location": {
          "line": 81,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'addItem'",
          "replacements": []
        }
      },
      {
        "detector_id": "integer-overflow",
        "message": "Function 'processItems' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs addition without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.",
        "severity": "high",
        "location": {
          "line": 72,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-190",
        "fix_suggestion": {
          "description": "Use SafeMath library in 'processItems' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'processItems' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 72,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'processItems'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'processItems' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 72,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'processItems'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'processItems' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 72,
          "column": 14,
          "length": 12
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'processItems'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'changeOwner' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 103,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'changeOwner'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'resetSecret' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 109,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'resetSecret'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_newOwner' in function 'changeOwner' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 103,
          "column": 34,
          "length": 9
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_newOwner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_newOwner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 103,
          "column": 34,
          "length": 9
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_newOwner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'createTransaction' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 136,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'createTransaction'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_recipient' in function 'createTransaction' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 136,
          "column": 40,
          "length": 10
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_recipient != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_recipient' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 136,
          "column": 40,
          "length": 10
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_recipient != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 136,
          "column": 60,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'createTransaction' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 136,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'createTransaction'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'createTransaction' does not check return value",
        "severity": "medium",
        "location": {
          "line": 136,
          "column": 14,
          "length": 17
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'createTransaction'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'createUser' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 157,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'createUser'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'approve' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 161,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'approve'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'deleteUser' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 166,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'deleteUser'",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_spender' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 161,
          "column": 30,
          "length": 8
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_spender != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_amount' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 161,
          "column": 48,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_amount > 0, \"Amount must be positive\");",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'createUser' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 157,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'createUser'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'approve' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 161,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'approve'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'deleteUser' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 166,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'deleteUser'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'deleteUser' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 166,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'deleteUser'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-approve-race",
        "message": "Function 'approve' has approve race condition vulnerability. Standard ERC-20 approve without race condition protection Vulnerable to front-running attack (SWC-114).",
        "severity": "medium",
        "location": {
          "line": 161,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Fix 'approve' race condition. Solutions: (1) Require current allowance == 0 before changes, (2) Use increaseAllowance/decreaseAllowance pattern, (3) Add expectedCurrentValue parameter",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'addValue' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 189,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'addValue'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'deleteValue' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 194,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'deleteValue'",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_value' of type 'uint' may need validation",
        "severity": "low",
        "location": {
          "line": 189,
          "column": 31,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add appropriate range validation for _value",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'addValue' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 189,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'addValue'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'addValue' does not check return value",
        "severity": "medium",
        "location": {
          "line": 189,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'addValue'",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'deleteValue' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 194,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'deleteValue'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "dos-unbounded-operation",
        "message": "Function 'getValue' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.",
        "severity": "high",
        "location": {
          "line": 202,
          "column": 14,
          "length": 8
        },
        "cwe": "CWE-834",
        "fix_suggestion": {
          "description": "Fix unbounded operation in 'getValue'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
          "replacements": []
        }
      }
    ]
  },
  {
    "contract": "analysis_summary",
    "total_findings": 0,
    "critical": 0,
    "high": 0,
    "medium": 0,
    "low": 0,
    "detectors": {
      "missing-access-modifiers": 4,
      "unprotected-initializer": 1,
      "invalid-state-transition": 3,
      "missing-zero-address-check": 5,
      "parameter-consistency": 5,
      "unchecked-external-call": 3,
      "test-governance": 4,
      "storage-collision": 1,
      "dangerous-delegatecall": 1,
      "vault-withdrawal-dos": 2,
      "vault-hook-reentrancy": 1,
      "mev-extractable-value": 4,
      "circular-dependency": 1,
      "gas-griefing": 2,
      "excessive-gas-usage": 1,
      "inefficient-storage": 2,
      "centralization-risk": 1,
      "shadowing-variables": 4,
      "aa-initialization-vulnerability": 3,
      "hardware-wallet-delegation": 2,
      "erc20-transfer-return-bomb": 1,
      "defi-yield-farming-exploits": 7,
      "floating-pragma": 1,
      "diamond-storage-collision": 2,
      "transient-storage-reentrancy": 2,
      "eip7702-init-frontrun": 1,
      "eip7702-delegate-access-control": 1,
      "eip7702-storage-collision": 1,
      "eip7702-txorigin-bypass": 1,
      "missing-commit-reveal": 1,
      "logic-error-patterns": 2,
      "enhanced-input-validation": 3,
      "enhanced-access-control": 1,
      "jit-liquidity-sandwich": 1,
      "single-oracle-source": 1,
      "validator-front-running": 1,
      "block-stuffing-vulnerable": 1,
      "front-running-mitigation": 1
    },
    "findings": [
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'changeOwner' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 19,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'changeOwner'",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'initialize' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 34,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'initialize'",
          "replacements": []
        }
      },
      {
        "detector_id": "unprotected-initializer",
        "message": "Initializer function 'initialize' lacks access control and can be called by anyone",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier to 'initialize' or ensure it can only be called once during deployment",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 28,
          "column": 9,
          "length": 51
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variable 'initialized' is modified without proper validation or state checks",
        "severity": "high",
        "location": {
          "line": 38,
          "column": 9,
          "length": 18
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Add proper validation before modifying state variables",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_newOwner' in function 'changeOwner' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 19,
          "column": 34,
          "length": 9
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_newOwner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_recipient' in function 'withdrawAll' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 34,
          "length": 10
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_recipient != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_owner' in function 'initialize' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 33,
          "length": 6
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_owner != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_target' in function 'execute' is not checked for zero address",
        "severity": "medium",
        "location": {
          "line": 42,
          "column": 30,
          "length": 7
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_target != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_newOwner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 19,
          "column": 34,
          "length": 9
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_newOwner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_recipient' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 25,
          "column": 34,
          "length": 10
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_recipient != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_owner' of type 'address' may need validation",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 33,
          "length": 6
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_owner != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_target' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 42,
          "column": 30,
          "length": 7
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_target != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'withdrawAll' does not check return value",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'withdrawAll'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 14,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Function 'execute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
        "severity": "medium",
        "location": {
          "line": 42,
          "column": 0,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Implement time-delayed voting rights requiring minimum holding periods.",
          "replacements": []
        }
      },
      {
        "detector_id": "storage-collision",
        "message": "Function 'execute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-662",
        "fix_suggestion": {
          "description": "Ensure storage layout compatibility in 'execute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.",
          "replacements": []
        }
      },
      {
        "detector_id": "dangerous-delegatecall",
        "message": "Function 'execute' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-829",
        "fix_suggestion": {
          "description": "Restrict delegatecall target in 'execute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'withdrawAll' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'withdrawAll' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-hook-reentrancy",
        "message": "Function 'withdrawAll' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Protect 'withdrawAll' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'withdrawAll' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'withdrawAll'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function '' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 49,
          "column": 5,
          "length": 0
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in ''. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "circular-dependency",
        "message": "Function 'execute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
        "severity": "high",
        "location": {
          "line": 42,
          "column": 14,
          "length": 7
        },
        "cwe": "CWE-674",
        "fix_suggestion": {
          "description": "Break circular dependency in 'execute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'withdrawAll' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'withdrawAll'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "excessive-gas-usage",
        "message": "Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
        "severity": "low",
        "location": {
          "line": 34,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 32,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "inefficient-storage",
        "message": "Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
        "severity": "low",
        "location": {
          "line": 34,
          "column": 0,
          "length": 30
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
          "replacements": []
        }
      },
      {
        "detector_id": "centralization-risk",
        "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-269",
        "fix_suggestion": {
          "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'withdrawAll' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'withdrawAll'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.",
        "severity": "high",
        "location": {
          "line": 34,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-306",
        "fix_suggestion": {
          "description": "Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
        "severity": "high",
        "location": {
          "line": 15,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
          "replacements": []
        }
      },
      {
        "detector_id": "aa-initialization-vulnerability",
        "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
        "severity": "high",
        "location": {
          "line": 21,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
          "replacements": []
        }
      },
      {
        "detector_id": "hardware-wallet-delegation",
        "message": "Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-672",
        "fix_suggestion": {
          "description": "Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "hardware-wallet-delegation",
        "message": "Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 40
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.",
          "replacements": []
        }
      },
      {
        "detector_id": "erc20-transfer-return-bomb",
        "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3146
        },
        "fix_suggestion": {
          "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No withdrawal fee accounting (fee bypass risk) in 'withdrawAll'",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Asset calculation missing totalSupply/totalAssets in 'withdrawAll'",
        "severity": "high",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No slippage protection on withdrawal in 'withdrawAll'",
        "severity": "medium",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add slippage: require(assets >= minAssets, \"Slippage too high\");",
          "replacements": []
        }
      },
      {
        "detector_id": "floating-pragma",
        "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
        "severity": "low",
        "location": {
          "line": 2,
          "column": 0,
          "length": 23
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
          "replacements": []
        }
      },
      {
        "detector_id": "diamond-storage-collision",
        "message": "Contract 'VulnerableWallet' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
        "severity": "critical",
        "location": {
          "line": 10,
          "column": 10,
          "length": 16
        },
        "cwe": "CWE-1321",
        "fix_suggestion": {
          "description": "Implement Diamond Storage pattern for 'VulnerableWallet': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.vulnerablewallet\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Classic reentrancy pattern with transient storage risk in 'withdrawAll'",
        "severity": "critical",
        "location": {
          "line": 25,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() \u2190 attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 \u2190 do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-init-frontrun",
        "message": "Unprotected initialization in 'initialize' - vulnerable to front-running takeover ($1.54M August 2025 attack)",
        "severity": "critical",
        "location": {
          "line": 34,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-7702 Front-Running Attack:\n\nCurrent code (VULNERABLE):\nfunction initialize(...) public {\nrequire(owner == address(0));\nowner = newOwner;  // \u274c Attacker can front-run!\n}\n\nAttack sequence:\n1. User signs EIP-7702 authorization\n2. Attacker sees authorization in mempool\n3. Attacker front-runs with initialize(attackerAddress)\n4. User's delegation is now controlled by attacker\n5. Attacker drains all assets\n\nFix 1: Authorization-based initialization\nfunction initialize(address _owner, bytes memory signature) public {\nrequire(owner == address(0));\n\n// \u2705 Verify user signed this specific initialization\nbytes32 hash = keccak256(abi.encodePacked(_owner, address(this)));\naddress signer = ECDSA.recover(hash, signature);\nrequire(signer == _owner, \"Invalid signature\");\n\nowner = _owner;\n}\n\nFix 2: Constructor initialization (if possible)\nconstructor(address _owner) {\nowner = _owner;  // \u2705 Set during deployment\n}\n\nFix 3: Factory pattern with immediate initialization\ncontract DelegateFactory {\nfunction createDelegate() public returns (address) {\nDelegate delegate = new Delegate(msg.sender);\nreturn address(delegate);\n}\n}\n\nFix 4: Commit-reveal with time-lock\nmapping(bytes32 => uint256) public commitments;\n\nfunction commitInit(bytes32 commitment) public {\ncommitments[commitment] = block.timestamp;\n}\n\nfunction initialize(address _owner, bytes32 salt) public {\nbytes32 commitment = keccak256(abi.encodePacked(_owner, salt));\nrequire(commitments[commitment] > 0, \"No commitment\");\nrequire(block.timestamp >= commitments[commitment] + 10 minutes);\n\nowner = _owner;\n}\n\nReal-World Loss: $1.54M (August 2025)",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-delegate-access-control",
        "message": "Missing access control in 'execute' - allows arbitrary execution",
        "severity": "critical",
        "location": {
          "line": 42,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-storage-collision",
        "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "eip7702-txorigin-bypass",
        "message": "tx.origin usage breaks with EIP-7702 delegation",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "EIP-7702 breaks tx.origin assumptions:\n\nBefore: tx.origin == msg.sender for EOAs\nAfter EIP-7702: tx.origin != msg.sender (msg.sender is delegate)\n\nFix: Use msg.sender instead:\nrequire(msg.sender == owner, \"Not owner\");",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-commit-reveal",
        "message": "Auction/bidding without commit-reveal - bids can be front-run",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Implement commit-reveal pattern:\n\nmapping(address => bytes32) public commitments;\nmapping(address => uint256) public bids;\nuint256 public commitDeadline;\nuint256 public revealDeadline;\n\n// Phase 1: Commit (hide bid amount)\nfunction commitBid(bytes32 commitment) external {\nrequire(block.timestamp < commitDeadline);\ncommitments[msg.sender] = commitment;\n}\n\n// Phase 2: Reveal (after commit deadline)\nfunction revealBid(uint256 amount, bytes32 salt) external payable {\nrequire(block.timestamp >= commitDeadline);\nrequire(block.timestamp < revealDeadline);\n\nbytes32 commitment = keccak256(abi.encode(amount, salt));\nrequire(commitment == commitments[msg.sender], \"Invalid reveal\");\nrequire(msg.value == amount, \"Amount mismatch\");\n\nbids[msg.sender] = amount;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n\u2705 CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n\u2705 BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
          "replacements": []
        }
      },
      {
        "detector_id": "logic-error-patterns",
        "message": "Reward distribution logic detected - verify precision and rounding",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Common reward distribution errors:\n\n1. Integer division truncation:\n\u274c reward = balance / users;  // Loses remainder\n\u2705 reward = balance * 1e18 / users / 1e18;\n\n2. Accumulating rounding errors:\n\u274c Track individual rewards that sum != total\n\u2705 Use lastUser = total - sum(others)\n\n3. Division before multiplication:\n\u274c (balance / total) * multiplier\n\u2705 (balance * multiplier) / total\n\n4. Missing remainder handling:\nuint256 perUser = total / userCount;\nuint256 remainder = total % userCount;\n// Handle remainder explicitly!",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Array access without length validation - can cause out-of-bounds access",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n\u2705 VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n\u2705 VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Transfer function without zero-value check - validate non-zero amounts",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n\u2705 VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n\u2705 COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-input-validation",
        "message": "Address parameter without zero-address validation",
        "severity": "medium",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n\u2705 VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n\u2705 VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
          "replacements": []
        }
      },
      {
        "detector_id": "enhanced-access-control",
        "message": "tx.origin used in access control - vulnerable to phishing attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "\u274c NEVER use tx.origin for access control:\nfunction withdraw() public {\nrequire(tx.origin == owner, \"Not owner\");\n// Vulnerable to phishing!\n}\n\nAttack scenario:\n1. Attacker deploys malicious contract\n2. Owner calls attacker contract\n3. Attacker contract calls victim.withdraw()\n4. tx.origin is still owner, check passes!\n5. Funds drained\n\n\u2705 ALWAYS use msg.sender:\nfunction withdraw() public {\nrequire(msg.sender == owner, \"Not owner\");\n// Safe: msg.sender is immediate caller\n}\n\nThe difference:\n- msg.sender: Immediate caller (can be contract)\n- tx.origin: Original EOA that started the transaction\n\nValid use of tx.origin:\n- Reject contract calls: require(tx.origin == msg.sender)\n- But NEVER for access control decisions",
          "replacements": []
        }
      },
      {
        "detector_id": "jit-liquidity-sandwich",
        "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
        "severity": "high",
        "location": {
          "line": 1,
          "column": 1,
          "length": 3146
        },
        "fix_suggestion": {
          "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'claimReward' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "single-oracle-source",
        "message": "Function 'claimReward' relies on a single oracle source, creating centralization risk",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-693",
        "fix_suggestion": {
          "description": "Use multiple oracle sources and implement price aggregation in function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'claimReward' does not check return value",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'claimReward'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 62,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "vault-withdrawal-dos",
        "message": "Function 'claimReward' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Protect 'claimReward' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
          "replacements": []
        }
      },
      {
        "detector_id": "validator-front-running",
        "message": "Function 'claimReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate validator front-running in 'claimReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'claimReward' contains variable shadowing. Parameter 'attackerAddress' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 14,
          "length": 11
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'claimReward'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation doesn't account for totalSupply in 'claimReward'",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Calculate rewards: rewardPerToken = (rewardRate * timeDelta * 1e18) / totalSupply;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "No timestamp tracking for reward accrual in 'claimReward'",
        "severity": "high",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Missing reward debt tracking (double-claim risk) in 'claimReward'",
        "severity": "critical",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;",
          "replacements": []
        }
      },
      {
        "detector_id": "defi-yield-farming-exploits",
        "message": "Reward calculation without precision multiplier (rounding errors) in 'claimReward'",
        "severity": "medium",
        "location": {
          "line": 68,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors",
          "replacements": []
        }
      },
      {
        "detector_id": "diamond-storage-collision",
        "message": "Contract 'PhishingAttacker' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.",
        "severity": "critical",
        "location": {
          "line": 58,
          "column": 10,
          "length": 16
        },
        "cwe": "CWE-1321",
        "fix_suggestion": {
          "description": "Implement Diamond Storage pattern for 'PhishingAttacker': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256(\"diamond.storage.phishingattacker\")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-access-modifiers",
        "message": "Function 'setBeneficiary' performs critical operations but lacks access control modifiers",
        "severity": "critical",
        "location": {
          "line": 101,
          "column": 14,
          "length": 14
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Add an access control modifier like 'onlyOwner' to function 'setBeneficiary'",
          "replacements": []
        }
      },
      {
        "detector_id": "invalid-state-transition",
        "message": "State variables modified after external call - potential reentrancy affecting state machine",
        "severity": "critical",
        "location": {
          "line": 97,
          "column": 9,
          "length": 52
        },
        "cwe": "CWE-841",
        "fix_suggestion": {
          "description": "Use checks-effects-interactions pattern or reentrancy guards",
          "replacements": []
        }
      },
      {
        "detector_id": "missing-zero-address-check",
        "message": "Address parameter '_beneficiary' in function 'setBeneficiary' is not checked for zero address",
        "severity": "high",
        "location": {
          "line": 101,
          "column": 37,
          "length": 12
        },
        "cwe": "CWE-476",
        "fix_suggestion": {
          "description": "Add require(_beneficiary != address(0), \"Zero address not allowed\");",
          "replacements": []
        }
      },
      {
        "detector_id": "parameter-consistency",
        "message": "Parameter '_beneficiary' of type 'address' may need validation",
        "severity": "low",
        "location": {
          "line": 101,
          "column": 37,
          "length": 12
        },
        "cwe": "CWE-20",
        "fix_suggestion": {
          "description": "require(_beneficiary != address(0), \"Invalid address\");",
          "replacements": []
        }
      },
      {
        "detector_id": "unchecked-external-call",
        "message": "External call in function 'endAuction' does not check return value",
        "severity": "medium",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-252",
        "fix_suggestion": {
          "description": "Check the return value of external calls in function 'endAuction'",
          "replacements": []
        }
      },
      {
        "detector_id": "test-governance",
        "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
        "severity": "high",
        "location": {
          "line": 84,
          "column": 0,
          "length": 20
        },
        "cwe": "CWE-284",
        "fix_suggestion": {
          "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
          "replacements": []
        }
      },
      {
        "detector_id": "block-stuffing-vulnerable",
        "message": "Function 'endAuction' is vulnerable to block stuffing attacks. Auction closes in single block without multi-block finalization period, vulnerable to block stuffing to prevent last-minute bids Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.",
        "severity": "high",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Mitigate block stuffing in 'endAuction'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'bid' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 88,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'bid'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "mev-extractable-value",
        "message": "Function 'endAuction' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
        "severity": "high",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Reduce MEV extractability in 'endAuction'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
          "replacements": []
        }
      },
      {
        "detector_id": "gas-griefing",
        "message": "Function 'endAuction' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
        "severity": "medium",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-400",
        "fix_suggestion": {
          "description": "Mitigate gas griefing in 'endAuction'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
          "replacements": []
        }
      },
      {
        "detector_id": "front-running-mitigation",
        "message": "Function 'bid' lacks front-running protection. Bidding function 'bid' lacks commit-reveal scheme. Attackers can see your bid and outbid you Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
        "severity": "high",
        "location": {
          "line": 88,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-362",
        "fix_suggestion": {
          "description": "Add front-running protection to 'bid'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'bid' contains variable shadowing. Parameter 'highestBid' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 88,
          "column": 14,
          "length": 3
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'bid'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "shadowing-variables",
        "message": "Function 'endAuction' contains variable shadowing. Parameter 'beneficiary' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
        "severity": "medium",
        "location": {
          "line": 95,
          "column": 14,
          "length": 10
        },
        "cwe": "CWE-710",
        "fix_suggestion": {
          "description": "Rename shadowing variables in 'endAuction'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
          "replacements": []
        }
      },
      {
        "detector_id": "transient-storage-reentrancy",
        "message": "Classic reentrancy pattern with transient storage risk in 'endAuction'",
        "severity": "critical",
        "location": {
          "line": 95,
          "column": 0,
          "length": 20
        },
        "fix_suggestion": {
          "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() \u2190 attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 \u2190 do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
          "replacements": []
        }
      }
    ]
  }
]